/*
 *     OpenVC, an open source VHDL compiler/simulator
 *     Copyright (C) 2010  Christian Reisinger
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package at.jku.ssw.openvc.codeGenerator

import org.objectweb.asm.{ClassWriter, Label, Opcodes, Type}

import at.jku.ssw.openvc.ast._
import at.jku.ssw.openvc.ast.concurrentStatements._
import at.jku.ssw.openvc.ast.sequentialStatements._
import at.jku.ssw.openvc.ast.declarations._
import at.jku.ssw.openvc.ast.expressions._
import at.jku.ssw.openvc.symbolTable._
import at.jku.ssw.openvc.VHDLCompiler.Configuration

import at.jku.ssw.openvs.RuntimeAnnotations._
import at.jku.ssw.openvs.VHDLRuntime
import at.jku.ssw.openvs.VHDLRuntime._
//http://groups.google.com/group/jvm-languages/browse_thread/thread/a355dfceb3fc56cb# Optimizations?
//http://wikis.sun.com/display/HotSpotInternals/PerformanceTechniques
//opcodes currently not used: jsr,monitorenter,monitorexit,pop2,ret,swap
object CodeGenerator {
  val RUNTIME = p(VHDLRuntime.getClass).init //remove $ from class name
  val OPENVS = RUNTIME.substring(0, RUNTIME.lastIndexOf('/') + 1) //something like at/jku/ssw/openvc , without VHDLRuntime
  private val OpenVCSignature = "generated by OpenVC 0.01"

  private final case class Context(cw: RichClassWriter, mv: RichMethodVisitor, loopLabels: Map[(Int, Int), LoopLabels], designUnit: String, fileSymbols: Seq[FileSymbol] = Seq())

  private object ExpressionContext {
    object JumpKind extends Enumeration {
      val TrueJump, FalseJump = Value
    }
  }

  private final case class ExpressionContext(trueJump: RichLabel, falseJump: RichLabel, kind: ExpressionContext.JumpKind.Value) {
    def invert: ExpressionContext = {
      val newKind = kind match {
        case ExpressionContext.JumpKind.TrueJump => ExpressionContext.JumpKind.FalseJump
        case ExpressionContext.JumpKind.FalseJump => ExpressionContext.JumpKind.TrueJump
      }
      ExpressionContext(trueJump = falseJump, falseJump = trueJump, kind = newKind)
    }
  }

  private final class LoopLabels(val continueLabel: RichLabel, val breakLabel: RichLabel)

  private def getJVMParameterList(list: Seq[RuntimeSymbol]): String = list.map(getJVMDataType).mkString

  def p(n: Class[_]): String = n.getName().replace('.', '/')

  def ci(n: Class[_]): String =
    if (n.isPrimitive()) {
      n match {
        case java.lang.Byte.TYPE => "B"
        case java.lang.Boolean.TYPE => "Z"
        case java.lang.Short.TYPE => "S"
        case java.lang.Character.TYPE => "C"
        case java.lang.Integer.TYPE => "I"
        case java.lang.Float.TYPE => "F"
        case java.lang.Double.TYPE => "D"
        case java.lang.Long.TYPE => "J"
        case java.lang.Void.TYPE => "V"
      }
    } else {
      if (n.getName.startsWith("scala.runtime")) n.getName.split('.').last.init match {
        case "Byte" => "B"
        case "Boolean" => "Z"
        case "Short" => "S"
        case "Char" => "C"
        case "Int" => "I"
        case "Float" => "F"
        case "Double" => "D"
        case "Long" => "J"
        case "Unit" => "V"
      }
      else "L" + p(n) + ";"
    }

  def getBoxedType(dataType: DataType): String = "L" + getBoxedName(dataType) + ";"

  def getBoxedName(dataType: DataType): String =
    dataType match {
      case _: IntegerType => p(classOf[java.lang.Integer])
      case _: RealType => p(classOf[java.lang.Double])
      case _: PhysicalType => p(classOf[java.lang.Long])
      case enumeration: EnumerationType =>
        if (enumeration == SymbolTable.booleanType || enumeration == SymbolTable.bitType) p(classOf[java.lang.Boolean])
        else if (enumeration.elements.size <= Byte.MaxValue) p(classOf[java.lang.Byte])
        else p(classOf[java.lang.Character])
    }

  def getMutableScalarAccessType(scalarType: ScalarType): String = "L" + getMutableScalarAccessName(scalarType) + ";"

  def getMutableScalarAccessName(scalarType: ScalarType): String =
    scalarType match {
      case _: IntegerType => p(classOf[MutableInteger])
      case _: RealType => p(classOf[MutableReal])
      case _: PhysicalType => ci(classOf[MutableLong])
      case enumeration: EnumerationType =>
        if (enumeration == SymbolTable.booleanType || enumeration == SymbolTable.bitType) p(classOf[MutableBoolean])
        else if (enumeration.elements.size <= Byte.MaxValue) p(classOf[MutableByte])
        else p(classOf[MutableCharacter])
    }

  def getJVMDataType(symbol: RuntimeSymbol): String =
    symbol match {
      case signal: SignalSymbol => ci(classOf[AbstractSignal[_]])
      case _ => getJVMDataType(symbol.dataType)
    }

  def getJVMDataType(dataType: DataType): String =
    dataType match {
      case _: IntegerType => "I"
      case _: RealType => "D"
      case _: PhysicalType => "J"
      case enumeration: EnumerationType =>
        if (enumeration == SymbolTable.booleanType || enumeration == SymbolTable.bitType) "Z"
        else if (enumeration.elements.size <= Byte.MaxValue) "B"
        else "C"
      case arrayType: ConstrainedArrayType => ("[" * arrayType.dimensions.size) + getJVMDataType(arrayType.elementType)
      case _: UnconstrainedArrayType => "L" + getJVMName(dataType) + ";"
      case record: RecordType => "L" + record.fullName() + ";"
      case fileType: FileType => "L" + getJVMName(dataType) + ";"
      case accessType: AccessType => accessType.pointerType match {
        case scalarType: ScalarType => getMutableScalarAccessType(scalarType)
        case otherType => getJVMDataType(otherType)
      }
    }

  def getJVMName(symbol: RuntimeSymbol): String =
    symbol match {
      case signal: SignalSymbol => p(classOf[AbstractSignal[_]])
      case _ => getJVMName(symbol.dataType)
    }

  private def getJVMName(dataType: DataType): String =
    dataType match {
      case arrayType: ArrayType =>
        if (dataType.name == "string") "java/lang/String"
        else OPENVS + "VHDLRuntime$RuntimeArray" + arrayType.dimensions.size + "D" + {
          arrayType.elementType match {
            case _: RecordType | _: AccessType => "AnyRef"
            case _: IntegerType => "Int"
            case _: RealType => "Double"
            case enumeration: EnumerationType =>
              if (enumeration == SymbolTable.booleanType || enumeration == SymbolTable.bitType) "Boolean"
              else if (enumeration.name == SymbolTable.characterType) "Char"
              else {
                if (enumeration.elements.size <= Byte.MaxValue) "Byte"
                else if (enumeration.elements.size <= Short.MaxValue) "Short"
                else "Int"
              }
          }
        }
      case record: RecordType => record.fullName()
      case fileType: FileType => p(classOf[RuntimeFile])
    }

  def getJVMArrayType(dataType: ScalarType): Int =
    dataType match {
      case _: IntegerType => Opcodes.T_INT
      case _: RealType => Opcodes.T_DOUBLE
      case _: PhysicalType => Opcodes.T_LONG
      case enumeration: EnumerationType =>
        if (enumeration == SymbolTable.booleanType || enumeration == SymbolTable.bitType) Opcodes.T_BOOLEAN
        else if (enumeration.elements.size <= Byte.MaxValue) Opcodes.T_BYTE
        else Opcodes.T_CHAR
    }

  def getNextIndex(dataType: DataType): Int =
    dataType match {
      case _: RealType | _: PhysicalType => 2
      case _ => 1
    }

  def apply(configuration: Configuration, sourceFileName: String, designFile: DesignFile): Unit = {
    acceptNode(designFile, null)

    def acceptList(nodes: Seq[ASTNode], context: Context): Unit = nodes.foreach(acceptNode(_, context))

    def acceptNode(node: ASTNode, context: Context): Unit = {
      node match {
        case DesignFile(designUnits) => acceptList(designUnits, context)
        case designUnit: DesignUnit => designUnit.libraryUnit.foreach(acceptNode(_, context))
        case packageBodyDeclaration: PackageBodyDeclaration => visitPackageBodyDeclaration(packageBodyDeclaration)
        case packageDeclaration: PackageDeclaration => visitPackageDeclaration(packageDeclaration)
        case entityDeclaration: EntityDeclaration => visitEntityDeclaration(entityDeclaration)
        case architectureDeclaration: ArchitectureDeclaration => visitArchitectureDeclaration(architectureDeclaration)
        case configurationDeclaration: ConfigurationDeclaration => visitConfigurationDeclaration(configurationDeclaration)
        //concurrent Statements
        case ifGenerateStmt: IfGenerateStatement => visitIfGenerateStatement(ifGenerateStmt, context)
        case forGenerateStmt: ForGenerateStatement => visitForGenerateStatement(forGenerateStmt)
        case componentInstantiationStmt: ComponentInstantiationStatement => visitComponentInstantiationStatement(componentInstantiationStmt)
        case processStmt: ProcessStatement => visitProcessStatement(processStmt, context)
        case blockStmt: BlockStatement => visitBlockStatement(blockStmt, context)
        //sequential Statements
        case throwStatement: ThrowStatement =>
          context.mv.createDebugLineNumberInformation(throwStatement)
          context.mv.throwNewException(p(classOf[VHDLRuntimeException]), throwStatement.message)
        case assertStmt: AssertStatement => visitAssertStatement(assertStmt, context)
        case waitStmt: WaitStatement => visitWaitStatement(waitStmt, context)
        case nextStmt: NextStatement => visitNextStatement(nextStmt, context)
        case exitStmt: ExitStatement => visitExitStatement(exitStmt, context)
        case nullStmt: NullStatement =>
          context.mv.createDebugLineNumberInformation(nullStmt)
          context.mv.NOP
        case reportStmt: ReportStatement => visitReportStatement(reportStmt, context)
        case returnStmt: ReturnStatement => visitReturnStatement(returnStmt, context)
        case loopStmt: LoopStatement => visitLoopStatement(loopStmt, context)
        case whileStmt: WhileStatement => visitWhileStatement(whileStmt, context)
        case forStmt: ForStatement => visitForStatement(forStmt, context)
        case signalAssignmentStmt: SignalAssignmentStatement => visitSignalAssignmentStatement(signalAssignmentStmt, context)
        case variableAssignmentStmt: VariableAssignmentStatement => visitVariableAssignmentStatement(variableAssignmentStmt, context)
        case procedureCallStmt: ProcedureCallStatement => visitProcedureCallStatement(procedureCallStmt, context)
        case caseStmt: CaseStatement => visitCaseStatement(caseStmt, context)
        case ifStmt: IfStatement => visitIfStatement(ifStmt, context)
        //declarative Items
        case variableDeclaration: VariableDeclaration => visitVariableDeclaration(variableDeclaration, context)
        case constantDeclaration: ConstantDeclaration => visitConstantDeclaration(constantDeclaration, context)
        case signalDeclaration: SignalDeclaration => visitSignalDeclaration(signalDeclaration, context)
        case fileDeclaration: FileDeclaration => visitFileDeclaration(fileDeclaration, context)
        case typeDeclaration: AbstractTypeDeclaration => visitTypeDeclaration(typeDeclaration, context)
        case functionDefinition: FunctionDefinition => visitFunctionDefinition(functionDefinition, context)
        case procedureDefinition: ProcedureDefinition => visitProcedureDefinition(procedureDefinition, context)
        case componentDeclaration: ComponentDeclaration => visitComponentDeclaration(componentDeclaration, context)
        case aliasDeclaration: AliasDeclaration => visitAliasDeclaration(aliasDeclaration, context)
        case _: FunctionDeclaration | _: ProcedureDeclaration | _: SubTypeDeclaration | _: AttributeDeclaration | _: AttributeSpecification | _: GroupTemplateDeclaration | _: GroupDeclaration => //nothing
      }
    }

    def acceptExpressionOption(expr: Option[Expression], mv: RichMethodVisitor, contextOption: Option[ExpressionContext] = None, createDebugLineNumberInformation: Boolean = true): Unit =
      expr.foreach(acceptExpression(_, mv, contextOption, createDebugLineNumberInformation))

    def acceptExpression(expr: Expression, mv: RichMethodVisitor, contextOption: Option[ExpressionContext] = None, createDebugLineNumberInformation: Boolean = true): Unit = {
      if (createDebugLineNumberInformation) mv.createDebugLineNumberInformation(expr)

      def toRelation(expr: Expression) = expr match {
        case _: LogicalExpression | _: Relation | _: Factor | EmptyExpression => expr
        case _ => Relation(expr.position, expr, Relation.Operator.NEQ, EmptyExpression, expr.dataType)
      }

      contextOption match {
        case Some(context) => acceptExpressionInner(toRelation(expr), context)
        case None =>
          expr.dataType match {
            case e: EnumerationType if (e == SymbolTable.booleanType || e == SymbolTable.bitType) =>
              expr match {
                case _: LogicalExpression | _: Relation =>
                  val trueLabel = RichLabel(mv)
                  val falseLabel = RichLabel(mv)
                  val afterLabel = RichLabel(mv)
                  import mv._
                  acceptExpressionInner(expr, ExpressionContext(trueLabel, falseLabel, ExpressionContext.JumpKind.TrueJump))

                  falseLabel()
                  ICONST_0
                  GOTO(afterLabel)
                  trueLabel()
                  ICONST_1
                  afterLabel()
                case _ => acceptExpressionInner(expr)
              }
            case _ => acceptExpressionInner(expr)
          }
      }

      def acceptExpressionInnerOption(expression: Option[Expression], innerContext: ExpressionContext): Unit = expression.foreach(acceptExpressionInner(_, innerContext))

      def acceptExpressionInner(expression: Expression, innerContext: ExpressionContext = null): Unit = {
        expression match {
          case EmptyExpression => //nothing
          case term: Term => visitTerm(term)
          case aggregateExpression: AggregateExpression => visitAggregateExpression(aggregateExpression)
          case typeCastExpr: TypeCastExpression => visitTypeCastExpression(typeCastExpr)
          case relation: Relation => visitRelation(relation, innerContext)
          case factor: Factor => visitFactor(factor, innerContext)
          case shiftExpression: ShiftExpression =>
            acceptExpressionInner(shiftExpression.left)
            acceptExpressionInner(shiftExpression.right)
            import ShiftExpression.Operator._
            val parameters = shiftExpression.operator match {
              case SLA | SRA =>
                //TODO is ascending? shiftExpression.dataType.asInstanceOf[ArrayType].dimensions
                mv.ICONST_1
                "(" + getJVMDataType(shiftExpression.left.dataType) + "IZ)"
              case _ => "(" + getJVMDataType(shiftExpression.left.dataType) + "I)"
            }
            mv.INVOKESTATIC(RUNTIME, shiftExpression.operator.toString, parameters + getJVMDataType(shiftExpression.left.dataType))
          case functionCallExpr: FunctionCallExpression => visitFunctionCallExpression(functionCallExpr)
          case logicalExpr: LogicalExpression => logicalExpr.dataType match {
            case _: ArrayType => visitLogicalExpression(logicalExpr, innerContext)
            case _ => visitLogicalExpression(logicalExpr.copy(left = toRelation(logicalExpr.left), right = toRelation(logicalExpr.right)), innerContext)
          }
          case simpleExpr: SimpleExpression => acceptExpressionInner(simpleExpr.left); acceptExpressionInnerOption(simpleExpr.rightOption, innerContext); visitSimpleExpression(simpleExpr)
          case newExpr: NewExpression => visitNewExpression(newExpr)
          case literal: Literal => visitLiteral(literal)
          case physicalLiteral: PhysicalLiteral => visitPhysicalLiteral(physicalLiteral)

          case ItemExpression(_, symbol) => mv.loadSymbol(symbol)
          case ArrayAccessExpression(symbol, indexes, dataType, expression) =>
            import mv._
            loadSymbol(symbol)
            symbol.dataType match {
              case constrainedArrayType: ConstrainedArrayType =>
                indexes.zipWithIndex.zip(constrainedArrayType.dimensions).foreach {
                  case ((expr, i), dim) =>
                    acceptExpressionInner(expr, innerContext)
                    if (dim.from != 0) {
                      pushInt(dim.from)
                      pushInt(dim.to)
                      INVOKESTATIC(RUNTIME, "getArrayIndex1D", "(III)I")
                    }
                    i match {
                      case 1 => arrayLoadInstruction(constrainedArrayType.elementType)
                      case _ => AALOAD
                    }
                }
              case unconstrainedArrayType: UnconstrainedArrayType =>
                indexes.foreach(acceptExpressionInner(_, innerContext))
                unconstrainedArrayType.elementType match {
                  case _: RecordType =>
                    INVOKEVIRTUAL(getJVMName(symbol), "getValue", "(" + ("I" * indexes.size) + ")" + "Ljava/lang/Object;")
                    CHECKCAST(getJVMName(unconstrainedArrayType.elementType))
                  case _ => INVOKEVIRTUAL(getJVMName(symbol), "getValue", "(" + ("I" * indexes.size) + ")" + getJVMDataType(unconstrainedArrayType.elementType))
                }
            }
            acceptExpressionInner(expression, innerContext)
          case attributeAccess: AttributeExpression => visitAttributeAccessExpression(attributeAccess)
          case FieldAccessExpression(symbol, field, fieldDataType, _, expression) =>
            if (!symbol.owner.isInstanceOf[RuntimeSymbol]) mv.loadSymbol(symbol)
            mv.GETFIELD(symbol.dataType.fullName(), field.text, getJVMDataType(fieldDataType))
            acceptExpressionInner(expression, innerContext)
          case e =>
            println(e.getClass.getName + " " + e.position)
            throw new IllegalArgumentException()
        }
      }

      def visitAttributeAccessExpression(attributeAccess: AttributeExpression): Unit = {
        attributeAccess.symbol match {
          case typeSymbol: TypeSymbol =>
            typeSymbol.dataType match {
              case scalarType: ScalarType =>
                attributeAccess.attribute.name match {
                  case "left" => mv.pushAnyVal(scalarType.left)
                  case "right" => mv.pushAnyVal(scalarType.right)
                  case "low" => mv.pushAnyVal(scalarType.lowerBound)
                  case "high" => mv.pushAnyVal(scalarType.upperBound)
                  case "ascending" => mv.pushBoolean(scalarType.ascending)
                  case "image" =>
                    acceptExpressionOption(attributeAccess.expression, mv)
                    scalarType match {
                      case _: IntegerType | _: RealType | _: PhysicalType => mv.INVOKESTATIC(getBoxedName(scalarType), "toString", "(" + getJVMDataType(scalarType) + ")Ljava/lang/String;")
                      case enumType: EnumerationType => mv.INVOKESTATIC(enumType.fullName(), "image", "(I)Ljava/lang/String;")
                    }
                  case "value" =>
                    acceptExpressionOption(attributeAccess.expression, mv)
                    scalarType match {
                      case _: IntegerType => mv.INVOKESTATIC("java/lang/Integer", "parseInt", "(Ljava/lang/String;)I")
                      case _: RealType => mv.INVOKESTATIC("java/lang/Double", "parseDouble", "(Ljava/lang/String;)D")
                      case _: PhysicalType => mv.INVOKESTATIC("java/lang/Long", "parseLong", "(Ljava/lang/String;)L")
                      case enumType: EnumerationType => mv.INVOKESTATIC(enumType.fullName(), "value", "(Ljava/lang/String;)I")
                    }
                  case "pos" | "val" | "succ" | "leftof" | "rightof" =>
                    error("not implemented")
                  /*scalarType match {
                    case _: IntegerType => mv.INVOKESTATIC(RUNTIME, attributeAccess.attribute.name, "(I)I")
                    case _: RealType => mv.INVOKESTATIC(RUNTIME, attributeAccess.attribute.name, "(D)D")
                    case enumType: EnumerationType => mv.INVOKESTATIC(enumType.fullName(), attributeAccess.attribute.name, "(I)I")
                  }*/
                  case "base" => error("not implemented")
                }
            }
          case signal: SignalSymbol if (signal.signalAttributes.contains(attributeAccess.attribute.name)) =>
            mv.loadSymbol(signal)
            acceptExpressionOption(attributeAccess.expression, mv)
            //"delayed" | "stable" | "quiet" | "transaction" | "event" | "active" | "last_event" | "last_active" | "last_value" | "driving" | "event" | "driving_value"
            mv.INVOKEVIRTUAL(getJVMName(signal), attributeAccess.attribute.name, if (attributeAccess.attribute.parameter.isDefined) "(L)" else "()" + getJVMDataType(attributeAccess.attribute.dataType))
          case symbol: RuntimeSymbol => symbol.dataType match {
            case arrayType: ArrayType =>
              mv.loadSymbol(symbol)
              acceptExpressionOption(attributeAccess.expression, mv)
              //"left" | "right" | "low" | "high" | "length" | "ascending"
              mv.INVOKEVIRTUAL(getJVMName(symbol), attributeAccess.attribute.name, "(I)" + getJVMDataType(attributeAccess.attribute.dataType))
          }
        }
      }

      def visitAggregateExpression(aggregateExpression: AggregateExpression): Unit = {
        //TODO
        val elements = aggregateExpression.aggregate.elements
        aggregateExpression.dataType match {
          case arrayType: ConstrainedArrayType =>
            arrayType.dimensions.size match {
              case 1 =>
                mv.pushInt(arrayType.dimensions.head.size)
                arrayType.elementType match {
                  case scalarType: ScalarType => mv.NEWARRAY(getJVMArrayType(scalarType))
                  case recordType: RecordType => mv.ANEWARRAY(recordType.fullName())
                }
              case size =>
                require(size == 2) //TODO make general for n dimensions
                arrayType.dimensions.foreach(dim => mv.pushInt(dim.size))
                //mv.MULTIANEWARRAY(("[" * (size-1) + getJVMDataType(arrayType.elementType), size)
                mv.ANEWARRAY(("[" * (size - 1)) + getJVMDataType(arrayType.elementType))
            }
            for ((element, i) <- aggregateExpression.aggregate.elements.zipWithIndex) {
              mv.DUP
              mv.pushInt(i)
              acceptExpression(element.expression, mv)
              arrayType.dimensions.size match {
                case 1 => mv.arrayStoreInstruction(arrayType.elementType)
                case _ => mv.AASTORE
              }
            }
          case record: RecordType =>
            import mv._
            NEW(record.fullName())
            DUP
            for (element <- aggregateExpression.aggregate.elements)
              acceptExpressionInner(element.expression)
            val desc = record.elementList.map(element => getJVMDataType(element._2)).mkString
            INVOKESPECIAL(record.fullName(), "<init>", "(" + desc + ")V")
        }
      }

      def visitFactor(factor: Factor, context: ExpressionContext): Unit = {
        import Factor.Operator._
        import mv._

        factor.operator match {
          case POW =>
            acceptExpressionInner(factor.left, context)
            acceptExpressionInner(factor.rightOption.get, context)
            INVOKESTATIC(RUNTIME, "pow", "(" + getJVMDataType(factor.dataType) + "I)" + getJVMDataType(factor.dataType)) //calls pow(II)I or pow(DI)D
          case ABS =>
            require(factor.rightOption.isEmpty)
            acceptExpressionInner(factor.left, context)
            INVOKESTATIC("java/lang/Math", "abs", "(" + getJVMDataType(factor.dataType) + ")" + getJVMDataType(factor.dataType)) //calls abs(I)I or abs(D)D or abs(L)L
          case NOT =>
            require(factor.rightOption.isEmpty)
            factor.dataType match {
              case arrayType: ArrayType =>
                acceptExpressionInner(factor.left, context)
                INVOKESTATIC(RUNTIME, "NOT", "([Z)[Z")
              case _ => acceptExpressionInner(toRelation(factor.left), context.invert)
            }
        }
      }

      def visitFunctionCallExpression(functionCallExpr: FunctionCallExpression): Unit = {
        val functionSymbol = functionCallExpr.symbol
        val functionCallType = if (functionSymbol.flags(Opcodes.ACC_STATIC)) Opcodes.INVOKESTATIC else {
          mv.ALOAD(0)
          Opcodes.INVOKEVIRTUAL
        }
        loadParameters(functionCallExpr.parameters, mv)
        mv.visitMethodInsn(functionCallType, functionSymbol.owner.name, functionSymbol.name, "(" + getJVMParameterList(functionSymbol.parameters) + ")" + getJVMDataType(functionSymbol.returnType))
      }

      def visitPhysicalLiteral(physicalLiteral: PhysicalLiteral): Unit = {
        import Literal.Type._
        import mv._
        val dataType = physicalLiteral.dataType.asInstanceOf[PhysicalType]
        physicalLiteral.literalType match {
          case INTEGER_LITERAL => pushLong(physicalLiteral.toLong * dataType.units(physicalLiteral.unitName.text))
          case REAL_LITERAL => pushLong((physicalLiteral.toDouble * dataType.units(physicalLiteral.unitName.text)).toLong)
        }
      }

      def visitLiteral(literal: Literal): Unit = {
        import Literal.Type._
        import mv._

        literal.literalType match {
          case STRING_LITERAL =>
            val pureString = literal.text.replace("\"", "")
            if (literal.dataType == SymbolTable.stringType) LDC(pureString)
            else {
              val dataType = literal.dataType.asInstanceOf[ArrayType].elementType.asInstanceOf[EnumerationType]
              pushInt(pureString.length)
              NEWARRAY(getJVMArrayType(dataType))
              pureString.zipWithIndex.foreach {
                case (c, i) =>
                  DUP
                  pushInt(i)
                  pushInt(dataType.intValue(c.toString))
                  arrayStoreInstruction(dataType)
              }
            }
          case INTEGER_LITERAL => pushInt(literal.toInt)
          case REAL_LITERAL => pushDouble(literal.toDouble)
          case CHARACTER_LITERAL => pushInt(literal.dataType.asInstanceOf[EnumerationType].intValue(literal.text.replace("'","")))
          case NULL_LITERAL => ACONST_NULL
        }
      }

      def visitNewExpression(newExpression: NewExpression): Unit =
        newExpression.qualifiedExpressionOrSubTypeIndication match {
          case Left(qualifiedExpression) => acceptExpression(qualifiedExpression, mv)
          case Right(subTypeIndication) =>
            import mv._
            val dataTypeName = getMutableScalarAccessName(newExpression.dataType.asInstanceOf[ScalarType])
            NEW(dataTypeName)
            DUP
            INVOKESPECIAL(dataTypeName, "<init>", "()V")
        }

      def visitLogicalExpression(logicalExpr: LogicalExpression, context: ExpressionContext, lastXORStatement: Boolean = true): Unit = {
        import LogicalExpression.Operator._
        import ExpressionContext.JumpKind._
        logicalExpr.dataType match {
          case arrayType: ArrayType =>
            acceptExpressionInner(logicalExpr.left, context)
            acceptExpressionInner(logicalExpr.right, context)
            mv.INVOKESTATIC(RUNTIME, logicalExpr.operator.toString, "([Z[Z)[Z")
          case _ =>
            //AND,NAND,OR,NOR are short-circuit operators
            // AND,NAND left expr == false => jump
            // OR, NOR left expr == true => jump
            def acceptExprCreateBoolValue(expr: Expression): Unit = {
              val trueLabel = RichLabel(mv)
              val falseLabel = RichLabel(mv)
              val afterLabel = RichLabel(mv)
              import mv._
              def createValues(): Unit = {
                trueLabel()
                ICONST_1
                GOTO(afterLabel)
                falseLabel()
                ICONST_0
                afterLabel()
              }
              val newContext = ExpressionContext(trueLabel, falseLabel, FalseJump)
              expr match {
                case logicalExpression: LogicalExpression =>
                  logicalExpression.operator match {
                    case XOR | XNOR => visitLogicalExpression(logicalExpression, newContext, false)
                    case _ =>
                      visitLogicalExpression(logicalExpression, newContext, false)
                      createValues()
                  }
                case _ =>
                  acceptExpressionInner(expr, newContext)
                  createValues()
              }
            }
            def newFalseLabel(label: RichLabel): RichLabel =
              if ((logicalExpr.left.isInstanceOf[LogicalExpression]) || context.kind == FalseJump) context.falseJump
              else label

            def newTrueLabel(label: RichLabel): RichLabel =
              if ((logicalExpr.left.isInstanceOf[LogicalExpression]) || context.kind == TrueJump) context.trueJump
              else label

            val afterLabel = RichLabel(mv)
            import mv._
            logicalExpr.operator match {
              case AND =>
                acceptExpressionInner(logicalExpr.left, context.copy(kind = FalseJump, falseJump = newFalseLabel(afterLabel)))
                acceptExpressionInner(logicalExpr.right, context)
                afterLabel()
              case NAND => visitFactor(Factor(logicalExpr.position, logicalExpr.copy(operator = AND), Factor.Operator.NOT, None, logicalExpr.dataType), context)
              case OR =>
                acceptExpressionInner(logicalExpr.left, context.copy(kind = TrueJump, trueJump = newTrueLabel(afterLabel)))
                acceptExpressionInner(logicalExpr.right, context)
                afterLabel()
              case NOR => visitFactor(Factor(logicalExpr.position, logicalExpr.copy(operator = OR), Factor.Operator.NOT, None, logicalExpr.dataType), context)
              case XOR =>
                acceptExprCreateBoolValue(logicalExpr.left)
                acceptExprCreateBoolValue(logicalExpr.right)
                IXOR
                if (lastXORStatement) {
                  context.kind match {
                    case TrueJump => IFNE(context.trueJump)
                    case FalseJump => IFEQ(context.falseJump)
                  }
                }
              case XNOR =>
                acceptExprCreateBoolValue(logicalExpr.left)
                acceptExprCreateBoolValue(logicalExpr.right)
                IXOR
                if (lastXORStatement) {
                  context.kind match {
                    case TrueJump => IFEQ(context.trueJump)
                    case FalseJump => IFNE(context.falseJump)
                  }
                }
            }
        }
      }

      def visitRelation(relation: Relation, context: ExpressionContext): Unit = {
        import Relation.Operator._
        import mv._

        val (jumpLabel, jumpInverted) = context.kind match {
          case ExpressionContext.JumpKind.TrueJump => (context.trueJump, false)
          case ExpressionContext.JumpKind.FalseJump => (context.falseJump, true)
        }
        relation.right match {
          case EmptyExpression =>
            acceptExpressionInner(relation.left, context)
            relation.operator match {
              case EQ => if (jumpInverted) IFNE(jumpLabel) else IFEQ(jumpLabel)
              case NEQ => if (jumpInverted) IFEQ(jumpLabel) else IFNE(jumpLabel)
            }
          case _ =>
            if (relation.left.dataType == NullType || relation.right.dataType == NullType) {
              if (relation.left.dataType == NullType) acceptExpressionInner(relation.right, context)
              else acceptExpressionInner(relation.left, context) //also handles the strange corner case where both expression are null literals, e.g. if (null=null) then ... or if (null/=null) then
              relation.operator match {
                case EQ => if (jumpInverted) IFNONNULL(jumpLabel) else IFNULL(jumpLabel)
                case NEQ => if (jumpInverted) IFNULL(jumpLabel) else IFNONNULL(jumpLabel)
              }
            }
            else {
              acceptExpressionInner(relation.left, context)
              acceptExpressionInner(relation.right, context)
              (relation.left.dataType: @unchecked) match {
                case arrayType: ArrayType =>
                  relation.operator match {
                    case EQ =>
                      if (arrayType.dimensions.size == 1) INVOKESTATIC("java/util/Arrays", "equals", "(" + (getJVMDataType(relation.left.dataType) * 2) + ")Z")
                      else INVOKESTATIC("java/util/Arrays", "deepEquals", "([Ljava/lang/Object;[Ljava/lang/Object;)Z")
                      if (jumpInverted) IFEQ(jumpLabel) else IFNE(jumpLabel)
                    case NEQ =>
                      if (arrayType.dimensions.size == 1) INVOKESTATIC("java/util/Arrays", "equals", "(" + (getJVMDataType(relation.left.dataType) * 2) + ")Z")
                      else INVOKESTATIC("java/util/Arrays", "deepEquals", "([Ljava/lang/Object;[Ljava/lang/Object;)Z")
                      if (jumpInverted) IFNE(jumpLabel) else IFEQ(jumpLabel)
                    case LT =>
                      INVOKESTATIC(RUNTIME, "LT", "(" + (getJVMDataType(relation.left.dataType) * 2) + ")Z")
                      if (jumpInverted) IFEQ(jumpLabel) else IFNE(jumpLabel)
                    case LEQ =>
                      INVOKESTATIC(RUNTIME, "LEQ", "(" + (getJVMDataType(relation.left.dataType) * 2) + ")Z")
                      if (jumpInverted) IFEQ(jumpLabel) else IFNE(jumpLabel)
                    //The relations > (greater than) and >= (greater than or equal) are defined to be the complements of the <= and < operators,
                    //respectively, for the same two operands.
                    case GT =>
                      INVOKESTATIC(RUNTIME, "LEQ", "(" + (getJVMDataType(relation.left.dataType) * 2) + ")Z")
                      if (jumpInverted) IFNE(jumpLabel) else IFEQ(jumpLabel)
                    case GEQ =>
                      INVOKESTATIC(RUNTIME, "LT", "(" + (getJVMDataType(relation.left.dataType) * 2) + ")Z")
                      if (jumpInverted) IFNE(jumpLabel) else IFEQ(jumpLabel)
                  }
                case recordType: RecordType =>
                  INVOKEVIRTUAL(recordType.fullName(), "equals", "(Ljava/lang/Object;)Z")
                  relation.operator match {
                    case EQ => if (jumpInverted) IFEQ(jumpLabel) else IFNE(jumpLabel)
                    case NEQ => if (jumpInverted) IFNE(jumpLabel) else IFEQ(jumpLabel)
                  }
                case _: AccessType =>
                  relation.operator match {
                    case EQ => if (jumpInverted) IF_ACMPNE(jumpLabel) else IF_ACMPEQ(jumpLabel)
                    case NEQ => if (jumpInverted) IF_ACMPEQ(jumpLabel) else IF_ACMPNE(jumpLabel)
                  }
                case _: IntegerType | _: EnumerationType =>
                  relation.operator match {
                    case EQ => if (jumpInverted) IF_ICMPNE(jumpLabel) else IF_ICMPEQ(jumpLabel)
                    case NEQ => if (jumpInverted) IF_ICMPEQ(jumpLabel) else IF_ICMPNE(jumpLabel)
                    case LT => if (jumpInverted) IF_ICMPGE(jumpLabel) else IF_ICMPLT(jumpLabel)
                    case LEQ => if (jumpInverted) IF_ICMPGT(jumpLabel) else IF_ICMPLE(jumpLabel)
                    case GT => if (jumpInverted) IF_ICMPLE(jumpLabel) else IF_ICMPGT(jumpLabel)
                    case GEQ => if (jumpInverted) IF_ICMPLT(jumpLabel) else IF_ICMPGE(jumpLabel)
                  }
                case _: RealType =>
                  relation.operator match {
                    case EQ => DCMPL; if (jumpInverted) IFNE(jumpLabel) else IFEQ(jumpLabel)
                    case NEQ => DCMPL; if (jumpInverted) IFEQ(jumpLabel) else IFNE(jumpLabel)
                    case LT => DCMPG; if (jumpInverted) IFGE(jumpLabel) else IFLT(jumpLabel)
                    case LEQ => DCMPG; if (jumpInverted) IFGT(jumpLabel) else IFLE(jumpLabel)
                    case GT => DCMPL; if (jumpInverted) IFLE(jumpLabel) else IFGT(jumpLabel)
                    case GEQ => DCMPL; if (jumpInverted) IFLT(jumpLabel) else IFGE(jumpLabel)
                  }
                case _: PhysicalType =>
                  LCMP
                  relation.operator match {
                    case EQ => if (jumpInverted) IFNE(jumpLabel) else IFEQ(jumpLabel)
                    case NEQ => if (jumpInverted) IFEQ(jumpLabel) else IFNE(jumpLabel)
                    case LT => if (jumpInverted) IFGE(jumpLabel) else IFLT(jumpLabel)
                    case LEQ => if (jumpInverted) IFGT(jumpLabel) else IFLE(jumpLabel)
                    case GT => if (jumpInverted) IFLE(jumpLabel) else IFGT(jumpLabel)
                    case GEQ => if (jumpInverted) IFLT(jumpLabel) else IFGE(jumpLabel)
                  }
              }
            }
        }
      }

      def visitSimpleExpression(simpleExpr: SimpleExpression): Unit = {
        import SimpleExpression._
        import mv._

        simpleExpr.addOperator.foreach {
          addOperator =>
            addOperator match {
              case AddOperator.PLUS =>
                simpleExpr.dataType match {
                  case _: IntegerType => IADD
                  case _: RealType => DADD
                  case _: PhysicalType => LADD
                }
              case AddOperator.MINUS =>
                simpleExpr.dataType match {
                  case _: IntegerType => ISUB
                  case _: RealType => DSUB
                  case _: PhysicalType => LSUB
                }
              case AddOperator.AMPERSAND =>
                if (simpleExpr.dataType.name == "string") {
                  INVOKESTATIC(RUNTIME, "stringAppend", "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;")
                } else throw new UnsupportedOperationException()
            }
        }
        simpleExpr.signOperator.foreach {
          signOperator =>
            signOperator match {
              case SignOperator.PLUS => // nothing
              case SignOperator.MINUS =>
                (simpleExpr.dataType: @unchecked) match {
                  case _: IntegerType => INEG
                  case _: RealType => DNEG
                  case _: PhysicalType => LNEG
                }
            }
        }
      }

      def visitTerm(term: Term): Unit = {
        import Term.Operator._
        import mv._

        def loadOperands(): Unit = {
          acceptExpressionInner(term.left)
          acceptExpressionInner(term.right)
        }
        ((term.left.dataType, term.right.dataType): @unchecked) match {
          case (_: IntegerType, _: IntegerType) =>
            loadOperands()
            term.operator match {
              case MUL => IMUL
              case DIV => IDIV
              case MOD => INVOKESTATIC(RUNTIME, "mod", "(II)I")
              case REM => IREM
            }
          case (_: RealType, _: RealType) =>
            loadOperands()
            (term.operator: @unchecked) match {
              case MUL => DMUL
              case DIV => DDIV
            }
          case (_: PhysicalType, _: IntegerType) =>
            loadOperands()
            I2L
            (term.operator: @unchecked) match {
              case MUL => LMUL
              case DIV => LDIV
            }
          case (_: PhysicalType, _: RealType) =>
            acceptExpressionInner(term.left)
            L2D
            acceptExpressionInner(term.right)
            (term.operator: @unchecked) match {
              case MUL => DMUL
              case DIV => DDIV
            }
            D2L
          case (_: IntegerType, _: PhysicalType) =>
            acceptExpressionInner(term.left)
            I2L
            acceptExpressionInner(term.right)
            LMUL
          case (_: RealType, _: PhysicalType) =>
            loadOperands()
            L2D
            DMUL
            D2L
          case (_: PhysicalType, _: PhysicalType) =>
            loadOperands()
            LDIV
            L2I
          case (_: RealType, _: IntegerType) =>
            loadOperands()
            I2D
            (term.operator: @unchecked) match {
              case MUL => DMUL
              case DIV => DDIV
            }
          case (_: IntegerType, _: RealType) =>
            acceptExpressionInner(term.left)
            I2D
            acceptExpressionInner(term.right)
            DMUL
        }
      }

      def visitTypeCastExpression(typeCastExpr: TypeCastExpression): Unit = {
        import mv._

        acceptExpressionInner(typeCastExpr.expression)

        typeCastExpr.dataType match {
          case _: IntegerType if typeCastExpr.expression.dataType.isInstanceOf[RealType] => D2I
          case _: RealType if typeCastExpr.expression.dataType.isInstanceOf[IntegerType] => I2D
        }
      }
    }

    def visitAssertStatement(assertStmt: AssertStatement, context: Context): Unit = {
      import context._

      mv.createDebugLineNumberInformation(assertStmt)

      val trueJumpLabel = RichLabel(mv)
      val falseJumpLabel = RichLabel(mv)
      acceptExpression(assertStmt.condition, mv, Some(new ExpressionContext(trueJump = trueJumpLabel, falseJump = falseJumpLabel, kind = ExpressionContext.JumpKind.TrueJump)))
      falseJumpLabel()

      mv.LDC(context.designUnit)
      acceptExpressionOption(assertStmt.reportExpression, mv)
      acceptExpressionOption(assertStmt.severityExpression, mv, None, false)
      val desc = "Ljava/lang/String;" +
              (if (assertStmt.reportExpression.isDefined) "Ljava/lang/String;" else "") +
              (if (assertStmt.severityExpression.isDefined) "I" else "")
      mv.INVOKESTATIC(RUNTIME, "assertVHDL", "(" + desc + ")V")

      trueJumpLabel()
    }

    def visitIfGenerateStatement(ifGenerateStmt: IfGenerateStatement, context: Context): Unit = {
      if (ifGenerateStmt.value) {
        //skip it
        acceptList(ifGenerateStmt.declarativeItems, context)
        acceptList(ifGenerateStmt.statementList, context)
      }
    }

    def visitIfStatement(ifStmt: IfStatement, context: Context): Unit = {
      import context._

      mv.createDebugLineNumberInformation(ifStmt)
      val endLabel = RichLabel(mv)

      def generateCodeForIfThenPart(part: IfStatement.IfThenPart, generateGOTO: Boolean): Unit = {
        val falseJump = RichLabel(mv)
        val trueJump = RichLabel(mv)
        acceptExpression(part.condition, mv, Some(new ExpressionContext(trueJump = trueJump, falseJump = falseJump, kind = ExpressionContext.JumpKind.FalseJump)))
        trueJump()
        acceptList(part.statements, context)
        if (generateGOTO && !part.statements.exists(_.isInstanceOf[ReturnStatement])) mv.GOTO(endLabel)
        falseJump()
      }

      val elseIfList = ifStmt.ifThenList.tail

      generateCodeForIfThenPart(ifStmt.ifThenList.head, !elseIfList.isEmpty || ifStmt.elseSequentialStatementList.isDefined)
      if (!elseIfList.isEmpty) {
        elseIfList.foreach(generateCodeForIfThenPart(_, true))
        generateCodeForIfThenPart(elseIfList.last, ifStmt.elseSequentialStatementList.isDefined)
      }
      ifStmt.elseSequentialStatementList.foreach(acceptList(_, context))

      endLabel()
    }


    def visitWaitStatement(waitStmt: WaitStatement, context: Context): Unit = {
      // TODO use continuations
      //import context._

      //mv.createDebugLineNumberInformation(waitStmt)
      //error("not implemented")
    }

    def createConditionalJump(stmt: SequentialStatement, condition: Option[Expression], targetLabel: RichLabel, context: Context): Unit = {
      import context._

      mv.createDebugLineNumberInformation(stmt)
      val trueJumpLabel = RichLabel(mv)
      val falseJumpLabel = RichLabel(mv)
      acceptExpressionOption(condition, mv, Some(new ExpressionContext(trueJump = trueJumpLabel, falseJump = falseJumpLabel, kind = ExpressionContext.JumpKind.FalseJump)))
      trueJumpLabel()
      mv.GOTO(targetLabel)
      falseJumpLabel()
    }

    def visitNextStatement(nextStmt: NextStatement, context: Context): Unit =
      createConditionalJump(nextStmt, nextStmt.condition, context.loopLabels(nextStmt.loopStatement).continueLabel, context)

    def visitExitStatement(exitStmt: ExitStatement, context: Context): Unit =
      createConditionalJump(exitStmt, exitStmt.condition, context.loopLabels(exitStmt.loopStatement).breakLabel, context)

    def visitForGenerateStatement(forGenerateStmt: ForGenerateStatement) = throw new UnsupportedOperationException()

    def visitForStatement(forStmt: ForStatement, context: Context): Unit = {
      import context._
      import Range.Direction._

      mv.createDebugLineNumberInformation(forStmt)
      val varIndex = forStmt.symbol.index
      val continueLabel = RichLabel(mv)
      val breakLabel = RichLabel(mv)
      val conditionTestLabel = RichLabel(mv)
      val startLabel = RichLabel(mv)
      startLabel()

      forStmt.discreteRange.rangeOrSubTypeIndication match {
        case Left(range) =>
          require(range.attributeNameOption.isEmpty)
          forStmt.symbol.owner match {
            case _: SubprogramSymbol =>
              acceptExpression(range.fromExpression, mv)
              mv.ISTORE(varIndex)
            case _: ProcessSymbol =>
              mv.ALOAD(0)
              acceptExpression(range.fromExpression, mv)
              mv.PUTFIELD(cw.className, forStmt.symbol.name, "I")
          }

          mv.GOTO(conditionTestLabel)
          continueLabel()

          val newContext = context.copy(loopLabels = context.loopLabels + ((forStmt.position.line, forStmt.position.charPosition) -> new LoopLabels(continueLabel, breakLabel)))
          acceptList(forStmt.sequentialStatementList, newContext)
          mv.createDebugLineNumberInformation(range.fromExpression)
          forStmt.symbol.owner match {
            case _: SubprogramSymbol =>
              range.direction match {
                case To => mv.IINC(varIndex, 1)
                case Downto => mv.IINC(varIndex, -1)
              }
              conditionTestLabel()
              mv.ILOAD(varIndex)
            case _: ProcessSymbol =>
              cw.visitField(Opcodes.ACC_PRIVATE, forStmt.symbol.name, "I", null)
              mv.ALOAD(0)
              mv.DUP
              mv.GETFIELD(cw.className, forStmt.symbol.name, "I")
              mv.ICONST_1
              range.direction match {
                case To => mv.IADD
                case Downto => mv.ISUB
              }
              mv.PUTFIELD(cw.className, forStmt.symbol.name, "I")
              conditionTestLabel()
              mv.ALOAD(0)
              mv.GETFIELD(cw.className, forStmt.symbol.name, "I")
          }
          acceptExpression(range.toExpression, mv)
          range.direction match {
            case To => mv.IF_ICMPLE(continueLabel)
            case Downto => mv.IF_ICMPGE(continueLabel)
          }
          breakLabel()
          if (forStmt.symbol.owner.isInstanceOf[SubprogramSymbol]) mv.visitLocalVariable(forStmt.symbol.name, "I", null, startLabel, breakLabel, varIndex)
      }
    }

    def visitLoopStatement(loopStmt: LoopStatement, context: Context): Unit = {
      val continueLabel = RichLabel(context.mv)
      val breakLabel = RichLabel(context.mv)
      import context.mv._

      createDebugLineNumberInformation(loopStmt)
      continueLabel()
      val newContext = context.copy(loopLabels = context.loopLabels + ((loopStmt.position.line, loopStmt.position.charPosition) -> new LoopLabels(continueLabel, breakLabel)))
      acceptList(loopStmt.sequentialStatementList, newContext)
      GOTO(continueLabel)
      breakLabel()
    }

    def createDefaultValuesFields(interfaceListOption: Option[InterfaceList], symbolList: Seq[RuntimeSymbol], parentName: String, cw: RichClassWriter): Unit =
      interfaceListOption.foreach {
        interfaceList =>
          val symbols = Map(symbolList.map(s => (s.name, s)): _*)
          for (element <- interfaceList.elements) {
            element.expression.foreach {
              expression =>
                for (id <- element.identifierList) {
                  val symbol = symbols(id.text)
                  cw.visitField(Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_STATIC, "$DEFAULT_" + parentName + "_" + symbol.name, getJVMDataType(symbol))
                }
            }
          }
      }

    def createDefaultValues(interfaceListOption: Option[InterfaceList], symbolList: Seq[RuntimeSymbol], parentName: String, cw: RichClassWriter, mv: RichMethodVisitor): Unit =
      interfaceListOption.foreach {
        interfaceList =>
          val symbols = Map(symbolList.map(s => (s.name, s)): _*)
          for (element <- interfaceList.elements) {
            element.expression.foreach {
              expression =>
                for (id <- element.identifierList) {
                  val symbol = symbols(id.text)
                  acceptExpression(expression, mv)
                  mv.PUTSTATIC(cw.className, "$DEFAULT_" + parentName + "_" + symbol.name, getJVMDataType(symbol))
                }
            }
          }
      }

    def initItems(designUnit: String, flags: Int, functionName: String, declarativeItems: Seq[ASTNode], cw: RichClassWriter, mvOption: Option[RichMethodVisitor] = None): Unit = {
      val nodes = declarativeItems.partition(node => node match {
        case _: ObjectDeclaration => true
        case _ => false
      })
      nodes._1.foreach(x => x.asInstanceOf[ObjectDeclaration].symbols.foreach {
        symbol => symbol match {
          case constantSymbol: ConstantSymbol => if (!(constantSymbol.isDeferred && constantSymbol.isDefined)) cw.visitField(Opcodes.ACC_PUBLIC + flags, symbol.name, getJVMDataType(symbol))
          case _ => cw.visitField(Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL + flags, symbol.name, getJVMDataType(symbol))
        }
      })
      val subPrograms = nodes._2.collect(_ match {
        case sub: SubProgramDefinition => sub
      })
      for (program <- subPrograms) {
        val parameters = program match {
          case function: FunctionDefinition => function.symbol.parameters
          case procedure: ProcedureDefinition => procedure.symbol.parameters
        }
        createDefaultValuesFields(program.parameterInterfaceList, parameters, program.identifier.text, cw)
      }
      {
        val mv = mvOption.getOrElse(cw.createMethod(flags = flags, name = functionName, parameters = "", returnType = "V"))
        acceptList(nodes._1, Context(cw, mv, Map(), designUnit))
        for (program <- subPrograms) {
          val parameters = program match {
            case function: FunctionDefinition => function.symbol.parameters
            case procedure: ProcedureDefinition => procedure.symbol.parameters
          }
          createDefaultValues(program.parameterInterfaceList, parameters, program.identifier.text, cw, mv)
        }
        if (mvOption.isEmpty) {
          mv.RETURN
          mv.endMethod
        }
      }
      acceptList(nodes._2, Context(cw, null, Map(), designUnit))
    }

    def visitComponentInstantiationStatement(componentInstantiationStmt: ComponentInstantiationStatement): Unit = {
      throw new UnsupportedOperationException()
    }

    def visitComponentDeclaration(componentDeclaration: ComponentDeclaration, context: Context): Unit = {
      val ports = componentDeclaration.symbol.ports
      val generics = componentDeclaration.symbol.generics
      val name = componentDeclaration.symbol.name
      val cw = createClass(Opcodes.ACC_FINAL, name, "java/lang/Object", classOf[ComponentAnnotation])

      createDefaultValuesFields(componentDeclaration.genericInterfaceList, componentDeclaration.symbol.generics, "COMPONENT", cw)
      createDefaultValuesFields(componentDeclaration.portInterfaceList, componentDeclaration.symbol.ports, "COMPONENT", cw)

      val mv = cw.createMethod(flags = Opcodes.ACC_STATIC, name = "<clinit>")
      createDefaultValues(componentDeclaration.genericInterfaceList, componentDeclaration.symbol.generics, "COMPONENT", cw, mv)
      createDefaultValues(componentDeclaration.portInterfaceList, componentDeclaration.symbol.ports, "COMPONENT", cw, mv)
      mv.endMethod

      cw.createMethod(flags = Opcodes.ACC_ABSTRACT, name = "instantiate", parameters = getJVMParameterList(generics) + getJVMParameterList(ports), returnType = "V")
      cw.writeToFile
    }

    def visitAliasDeclaration(aliasDeclaration: AliasDeclaration, context: Context): Unit = {

    }

    def visitPackageDeclaration(packageDeclaration: PackageDeclaration): Unit = {
      val cw = createClass(Opcodes.ACC_ABSTRACT, packageDeclaration.identifier.text + "_header", "java/lang/Object", classOf[PackageHeaderAnnotation])
      initItems(packageDeclaration.identifier.text, Opcodes.ACC_STATIC, "<clinit>", packageDeclaration.declarativeItems, cw)
      cw.writeToFile
    }

    def visitPackageBodyDeclaration(packageBodyDeclaration: PackageBodyDeclaration): Unit = {
      val cw = createClass(Opcodes.ACC_FINAL, packageBodyDeclaration.identifier.text, packageBodyDeclaration.identifier.text + "_header", classOf[PackageBodyAnnotation])
      initItems(packageBodyDeclaration.identifier.text, Opcodes.ACC_STATIC, "<clinit>", packageBodyDeclaration.declarativeItems, cw)
      cw.writeToFile
    }

    def visitArchitectureDeclaration(architectureDeclaration: ArchitectureDeclaration): Unit = {
      val cw = createClass(Opcodes.ACC_FINAL, architectureDeclaration.identifier.text, architectureDeclaration.entitySymbol.name, classOf[ArchitectureAnnotation], createEmptyConstructor = false)
      val ports = architectureDeclaration.entitySymbol.ports
      val generics = architectureDeclaration.entitySymbol.generics
      val combinedList = generics ++ ports
      combinedList.foreach(s => cw.visitField(Opcodes.ACC_PUBLIC, s.name, getJVMDataType(s)))

      val processDeclarations = architectureDeclaration.statementList.collect(_ match {
        case x: ProcessStatement => x
      })
      val processSymbols = processDeclarations.map(_.symbol)

      processSymbols.zip(processDeclarations) foreach {
        x =>
          val (symbol, processStmt) = x
          val className = if (processStmt.postponed) classOf[PostponedProcessAnnotation].getName.replace('.', '/') else classOf[ProcessAnnotation].getName.replace('.', '/')
          cw.visitField(Opcodes.ACC_PUBLIC, symbol.name, "L" + cw.className + "$" + symbol.name + ";").
                  visitAnnotation("L" + className + ";", true).
                  visitEnd
      }

      {
        val mv, rmv = cw.createMethod(name = "<init>", parameters = getJVMParameterList(generics) + getJVMParameterList(ports), returnType = "V")
        import rmv._

        ALOAD(0)
        INVOKESPECIAL("java/lang/Object", "<init>", "()V")
        for ((symbol, i) <- combinedList zipWithIndex) {
          ALOAD(0)
          loadInstruction(symbol.dataType, i + 1)
          PUTFIELD(cw.className, symbol.name, getJVMDataType(symbol))
        }
        initItems(architectureDeclaration.identifier.text, 0, "<init>", architectureDeclaration.declarativeItems, cw, Some(mv))
        processSymbols.foreach {
          symbol =>
            ALOAD(0)
            NEW(cw.className + "$" + symbol.name)
            DUP
            ALOAD(0)
            INVOKESPECIAL(cw.className + "$" + symbol.name, "<init>", "(L" + cw.className + ";)V")
            PUTFIELD(cw.className, symbol.name, "L" + cw.className + "$" + symbol.name + ";")
        }
        RETURN
        endMethod
      }
      val newContext = Context(cw, null, Map(), architectureDeclaration.identifier.text)
      acceptList(architectureDeclaration.statementList, newContext)
      cw.writeToFile
    }

    def visitConfigurationDeclaration(configurationDeclaration: ConfigurationDeclaration): Unit = {
      error("not implemented")
    }

    def visitEntityDeclaration(entityDeclaration: EntityDeclaration): Unit = {
      val cw = createClass(Opcodes.ACC_ABSTRACT, entityDeclaration.identifier.text, "java/lang/Object", classOf[EntityAnnotation])

      createDefaultValuesFields(entityDeclaration.genericInterfaceList, entityDeclaration.symbol.generics, "ENTITY", cw)
      createDefaultValuesFields(entityDeclaration.portInterfaceList, entityDeclaration.symbol.ports, "ENTITY", cw)

      val mv = cw.createMethod(flags = Opcodes.ACC_STATIC, name = "<clinit>")
      createDefaultValues(entityDeclaration.genericInterfaceList, entityDeclaration.symbol.generics, "ENTITY", cw, mv)
      createDefaultValues(entityDeclaration.portInterfaceList, entityDeclaration.symbol.ports, "ENTITY", cw, mv)
      initItems(entityDeclaration.identifier.text, Opcodes.ACC_STATIC, "<clinit>", entityDeclaration.declarativeItems, cw, Some(mv))
      mv.RETURN
      mv.endMethod

      acceptList(entityDeclaration.concurrentStatements, Context(cw = cw, mv = null, loopLabels = Map(), designUnit = entityDeclaration.identifier.text))
      cw.writeToFile
    }

    def visitReportStatement(reportStmt: ReportStatement, context: Context): Unit = {
      import context._

      mv.createDebugLineNumberInformation(reportStmt)
      mv.LDC(context.designUnit)
      acceptExpression(reportStmt.reportExpression, mv)
      acceptExpressionOption(reportStmt.severityExpression, mv)
      val desc = "Ljava/lang/String;Ljava/lang/String;" + (if (reportStmt.severityExpression.isDefined) "I" else "")
      mv.INVOKESTATIC(RUNTIME, "report", "(" + desc + ")V")
    }

    def visitReturnStatement(returnStmt: ReturnStatement, context: Context): Unit = {
      import context._

      mv.createDebugLineNumberInformation(returnStmt)
      //An implicit call to FILE_CLOSE exists in a subprogram body for every file object declared in the corresponding subprogram declarative part.
      //Each such call associates a unique file object with the formal parameter F and is called whenever the corresponding subprogram completes its execution.
      //close all open files in a subprogram before we return from it
      context.fileSymbols.foreach {
        symbol =>
          mv.ALOAD(symbol.index)
          mv.INVOKESTATIC(RUNTIME, "file_close", "(" + ci(classOf[RuntimeFile]) + ")V")
      }
      returnStmt.expression match {
        case None =>
          val procedureSymbol = returnStmt.procedureSymbol
          import context.mv._
          //returns the copyBack Symbols
          procedureSymbol.copyBackSymbols match {
            case Seq() => RETURN
            case Seq(symbol) =>
              //we have only one symbols
              loadSymbol(symbol)
              symbol.dataType.asInstanceOf[ScalarType] match {
                case _: IntegerType | _: EnumerationType => IRETURN
                case _: RealType => DRETURN
                case _: PhysicalType => LRETURN
              }
            case _ =>
              //we need to return more than one symbol, so we create a scala TupleX
              NEW("scala/Tuple" + procedureSymbol.copyBackSymbols.size)
              DUP
              procedureSymbol.copyBackSymbols.foreach {
                symbol =>
                  loadSymbol(symbol)
                  INVOKESTATIC(getBoxedName(symbol.dataType), "valueOf", "(" + getJVMDataType(symbol.dataType) + ")" + getBoxedType(symbol.dataType))
              }
              INVOKESPECIAL("scala/Tuple" + procedureSymbol.copyBackSymbols.size, "<init>", "(" + (("Ljava/lang/Object;") * procedureSymbol.copyBackSymbols.size) + ")V")
              ARETURN
          }
        case Some(expr) =>
          acceptExpression(expr, mv)
          expr.dataType match {
            case _: IntegerType | _: EnumerationType => mv.IRETURN
            case _: RealType => mv.DRETURN
            case _: PhysicalType => mv.LRETURN
            case _ => mv.ARETURN
          }
      }
    }

    def storeSymbol(mv: RichMethodVisitor, symbol: RuntimeSymbol, targetType: DataType): Unit =
      symbol.owner match {
        case _: ArchitectureSymbol => mv.PUTFIELD(symbol.owner.name, symbol.name, getJVMDataType(symbol))
        case typeSymbol: TypeSymbol =>
          mv.ALOAD(0)
          mv.PUTFIELD("alu_tb$sharedcounter", symbol.name, getJVMDataType(symbol))
        case _: PackageHeaderSymbol | _: PackageBodySymbol | _: ProcessSymbol => mv.PUTSTATIC(symbol.owner.name, symbol.name, getJVMDataType(symbol))
        case _: SubprogramSymbol => mv.storeInstruction(symbol)
        case r: RuntimeSymbol => symbol.dataType match {
          case record: RecordType =>
            mv.PUTFIELD(record.fullName(), symbol.name, getJVMDataType(targetType))
          case accessType: AccessType =>
            mv.PUTFIELD(getJVMName(accessType.pointerType), symbol.name, getJVMDataType(targetType))
          case constraintArray: ConstrainedArrayType =>
            mv.arrayStoreInstruction(constraintArray.elementType)
          case unconstrainedArrayType: UnconstrainedArrayType =>
            mv.INVOKEVIRTUAL(getJVMName(unconstrainedArrayType), "setValue", "(" + ("I" * unconstrainedArrayType.dimensions.size) + getJVMDataType(unconstrainedArrayType.elementType) + ")V")
        }
      }

    def loadTarget(mv: RichMethodVisitor, expression: Expression): (RuntimeSymbol, DataType) =
      (expression: @unchecked) match {
        case ItemExpression(_, symbol) => (symbol, symbol.dataType)
        case ArrayAccessExpression(symbol, _, dataType, EmptyExpression) =>
          (symbol, dataType)
        case ArrayAccessExpression(symbol, indexes, dataType, expression) =>
          mv.loadSymbol(symbol)
          symbol.dataType match {
            case constraintArray: ConstrainedArrayType =>
              indexes.zipWithIndex.zip(constraintArray.dimensions).foreach {
                case ((expr, i), dim) =>
                  acceptExpression(expr, mv)
                  if (dim.from != 0) {
                    mv.pushInt(dim.from)
                    mv.pushInt(dim.to)
                    mv.INVOKESTATIC(RUNTIME, "getArrayIndex1D", "(III)I")
                  }
                  i match {
                    case 1 => mv.arrayLoadInstruction(constraintArray.elementType)
                    case _ => mv.AALOAD
                  }
              }
            case unconstrainedArrayType: UnconstrainedArrayType =>
              indexes.foreach(acceptExpression(_, mv))
              unconstrainedArrayType.elementType match {
                case _: RecordType =>
                  mv.INVOKEVIRTUAL(getJVMName(symbol), "getValue", "(" + ("I" * indexes.size) + ")" + "Ljava/lang/Object;")
                  mv.CHECKCAST(getJVMName(unconstrainedArrayType.elementType))
                case _ => mv.INVOKEVIRTUAL(getJVMName(symbol), "getValue", "(" + ("I" * indexes.size) + ")" + getJVMDataType(unconstrainedArrayType.elementType))
              }
          }
          loadTarget(mv, expression)
        case fieldExpr@FieldAccessExpression(owner, field, fieldDataType, _, EmptyExpression) =>
          if (!owner.owner.isInstanceOf[RuntimeSymbol]) mv.loadSymbol(owner)
          (owner.makeCopy(field, owner.dataType), fieldDataType)
        case FieldAccessExpression(symbol, field, fieldDataType, _, expression) =>
          if (!symbol.owner.isInstanceOf[RuntimeSymbol]) mv.loadSymbol(symbol)
          mv.GETFIELD(symbol.dataType.fullName(), field.text, getJVMDataType(fieldDataType))
          loadTarget(mv, expression)
      }

    def visitVariableAssignmentStatement(varAssignStmt: VariableAssignmentStatement, context: Context): Unit = {
      import context._

      def checkIsInRange(dataType: DataType): Unit =
        dataType match {
          case scalarType: ScalarType =>
            if (scalarType.isSubType) {
              import mv._

              pushAnyVal(scalarType.lowerBound)
              pushAnyVal(scalarType.upperBound)
              scalarType match {
                case _: IntegerType | _: RealType | _: PhysicalType =>
                  val typeString = getJVMDataType(scalarType)
                  INVOKESTATIC(RUNTIME, "checkIsInRange", "(" + (typeString * 3) + ")" + typeString)
                case enumType: EnumerationType => INVOKESTATIC(enumType.baseType.get.fullName(), "checkIsInRange", "(III)I")
              }
            }
          case _ =>
        }

      mv.createDebugLineNumberInformation(varAssignStmt)
      varAssignStmt match {
        case stmt: SimpleVariableAssignmentStatement =>
          stmt.target.nameOrAggregate match {
            case Left(name) =>
              val (target, targetType) = loadTarget(mv, stmt.nameExpression)
              acceptExpression(stmt.expression, mv)
              checkIsInRange(targetType)
              storeSymbol(mv, target, targetType)
            case Right(aggregate) => error("not implemented")
          }
      }
    }

    def visitWhileStatement(whileStmt: WhileStatement, context: Context): Unit = {
      val conditionTestLabel = RichLabel(context.mv)
      val breakLabel = RichLabel(context.mv)
      val continueLabel = RichLabel(context.mv)
      import context.mv._

      createDebugLineNumberInformation(whileStmt)
      GOTO(conditionTestLabel)
      continueLabel()
      val newContext = context.copy(loopLabels = context.loopLabels + ((whileStmt.position.line, whileStmt.position.charPosition) -> new LoopLabels(conditionTestLabel, breakLabel)))
      acceptList(whileStmt.sequentialStatementList, newContext)
      conditionTestLabel()
      acceptExpression(whileStmt.condition, context.mv, Some(new ExpressionContext(trueJump = continueLabel, falseJump = breakLabel, kind = ExpressionContext.JumpKind.TrueJump)))
      breakLabel()
    }

    def visitFunctionDefinition(functionDefinition: FunctionDefinition, context: Context): Unit = {
      val functionSymbol = functionDefinition.symbol
      val mv = context.cw.createMethod(flags = functionSymbol.flags.sum, name = functionSymbol.name,
        parameters = getJVMParameterList(functionSymbol.parameters), returnType = getJVMDataType(functionSymbol.returnType))
      val startLabel = RichLabel(mv)
      val stopLabel = RichLabel(mv)

      startLabel()
      val newContext = Context(context.cw, mv, Map(), context.designUnit, functionDefinition.localSymbols.collect(_ match {case f: FileSymbol => f}))
      acceptList(functionDefinition.declarativeItems, newContext)
      acceptList(functionDefinition.sequentialStatementList, newContext)
      stopLabel()
      mv.createDebugLocalVariableInformation(functionDefinition.localSymbols, startLabel, stopLabel)
      mv.endMethod
    }

    def visitProcedureDefinition(procedureDefinition: ProcedureDefinition, context: Context): Unit = {
      val procedureSymbol = procedureDefinition.symbol

      val (returnType, signature) = procedureSymbol.copyBackSymbols match {
        case Seq() => ("V", null)
        case Seq(symbol) => (getJVMDataType(symbol), null)
        case _ =>
          ("Lscala/Tuple" + procedureSymbol.copyBackSymbols.size + ";",
                  "()Lscala/Tuple" + procedureSymbol.copyBackSymbols.size + "<" + procedureSymbol.copyBackSymbols.map(symbol => getBoxedType(symbol.dataType)).mkString + ">;")
      }

      val mv = context.cw.createMethod(flags = procedureSymbol.flags.sum, name = procedureSymbol.name, parameters = getJVMParameterList(procedureSymbol.parameters), returnType = returnType, signature = signature)
      val startLabel = RichLabel(mv)
      val stopLabel = RichLabel(mv)

      startLabel()
      val newContext = Context(context.cw, mv, Map(), context.designUnit, procedureDefinition.localSymbols.collect(_ match {case f: FileSymbol => f}))
      acceptList(procedureDefinition.declarativeItems, newContext)
      acceptList(procedureDefinition.sequentialStatementList, newContext)
      visitReturnStatement(ReturnStatement(Position.Empty, None, None, procedureSymbol), newContext)
      stopLabel()
      mv.createDebugLocalVariableInformation(procedureDefinition.localSymbols, startLabel, stopLabel)
      mv.endMethod
    }

    def visitBlockStatement(blockStmt: BlockStatement, context: Context): Unit = {
      val name = blockStmt.label match {
        case None => "block_" + blockStmt.position.line
        case Some(label) => label.text
      }
      val className = context.cw.className + "$" + name

      require(blockStmt.guardExpression.isEmpty)
      //createGetSensitivityList(context, name, processStmt.symbol.sensitivityList)

      context.cw.visitInnerClass(className, context.cw.className, name, Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC)
      val cw = createClass(Opcodes.ACC_FINAL + Opcodes.ACC_SYNTHETIC, className, "java/lang/Object", classOf[BlockAnnotation], createEmptyConstructor = false)
      cw.visitInnerClass(className, context.cw.className, name, Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC)
      cw.visitField(Opcodes.ACC_PRIVATE + Opcodes.ACC_FINAL, "architecture", "L" + context.cw.className + ";")

      {
        val mv = cw.createMethod(name = "<init>", parameters = "L" + context.cw.className + ";")
        import mv._

        ALOAD(0)
        INVOKESPECIAL("java/lang/Object", "<init>", "()V")
        ALOAD(0)
        ALOAD(1)
        PUTFIELD(cw.className, "architecture", "L" + context.cw.className + ";")
        RETURN
        endMethod
      }

      initItems(context.designUnit, Opcodes.ACC_STATIC, "init", blockStmt.declarativeItems, cw)
      acceptList(blockStmt.statementList, Context(cw = cw, mv = null, loopLabels = Map(), designUnit = context.designUnit))
      cw.writeToFile
      error("not implemented")
    }

    def visitCaseStatement(caseStmt: CaseStatement, context: Context): Unit = {
      val endLabel = RichLabel(context.mv)
      val defaultLabel = new Label()

      val labelList = caseStmt.alternatives.flatMap {
        alternative =>
          val label = new Label()
          alternative.choices.elements.map(choice => if (choice.isOthers) defaultLabel else label)
      }
      import context.mv._

      createDebugLineNumberInformation(caseStmt)
      acceptExpression(caseStmt.expression, context.mv)
      val keys = caseStmt.keys.sortBy(key => key)
      val firstKey = keys.head
      val lastKey = keys.last
      val labels = labelList.zip(caseStmt.keys).sortBy(x => x._2).unzip._1.toArray
      if (keys.distinct.size == (lastKey - firstKey + 1)) TABLESWITCH(firstKey, lastKey, defaultLabel, labels)
      else LOOKUPSWITCH(defaultLabel, keys.toArray, labels)

      for ((alternative, label) <- caseStmt.alternatives.zip(labelList.distinct)) {
        visitLabel(label)
        acceptList(alternative.statements, context)
        if (!alternative.statements.exists(_.isInstanceOf[ReturnStatement]) && (label ne defaultLabel)) GOTO(endLabel)
      }
      endLabel()
    }

    def visitProcedureCallStatement(procedureCallStmt: ProcedureCallStatement, context: Context): Unit = {
      import context._

      mv.createDebugLineNumberInformation(procedureCallStmt)
      val procedureSymbol = procedureCallStmt.symbol
      val procedureCallType = if (procedureSymbol.flags(Opcodes.ACC_STATIC)) Opcodes.INVOKESTATIC else
        {
          mv.ALOAD(0)
          Opcodes.INVOKEVIRTUAL
        }
      procedureSymbol.owner match {
        case Runtime =>
          //implicitly declared procedures and functions
          val procedureName = procedureSymbol.name match {
            case "deallocate" =>
              //converts a call to deallocate to a assignment with null => variable=null;
              require(procedureCallStmt.parameters.size == 1)
              val (target, targetType) = loadTarget(mv, procedureCallStmt.parameters.head)
              mv.ACONST_NULL
              storeSymbol(mv, target, targetType)
              None
            case "read" =>
              //mangle read procedure name so that it matches one of the readX names in the runtime
              Some("read" + getJVMDataType(procedureSymbol.parameters.head.dataType.asInstanceOf[FileType].elementType))
            case "file_open" =>
              if (procedureSymbol.parameters.head.dataType.name == "status") Some("file_open_status")
              else Some("file_open")
            case name => Some(name)
          }
          procedureName.foreach {
            loadParameters(procedureCallStmt.parameters, mv)
            mv.visitMethodInsn(procedureCallType, procedureSymbol.owner.name, _, "(" + getJVMParameterList(procedureSymbol.parameters) + ")V")
          }
        case _ =>
          loadParameters(procedureCallStmt.parameters, mv)
          mv.visitMethodInsn(procedureCallType, procedureSymbol.owner.name, procedureSymbol.name, "(" + getJVMParameterList(procedureSymbol.parameters) + ")V")
      }
      if (procedureSymbol.needsCopyBack) {
        //TODO call checkIsInRange
        //it is similarly an error if, after applying any conversion function or type conversion present in the formal part of the applicable association element, the value of the formal parameter does not
        //belong to the subtype denoted by the subtype indication of the actual.
        error("not implemented") //copy back scalar variables
      }
    }

    def createGetSensitivityList(context: Context, name: String, sensitivityList: Seq[SignalSymbol]): Unit = {
      //creates code which is the same as : def getSensitivityListProcessName:Seq[Signal]=List(signal1,signal2)
      val mv = context.cw.visitMethod(Opcodes.ACC_PUBLIC + Opcodes.ACC_SYNTHETIC, "getSensitivityList" + name,
        "()Lscala/collection/Seq;", "()Lscala/collection/Seq<" + ci(classOf[AbstractSignal[_]]) + ">;")

      import mv._

      visitCode()
      if (sensitivityList.isEmpty) {
        GETSTATIC("scala/collection/immutable/Nil$", "MODULE$", "Lscala/collection/immutable/Nil$;")
      }
      else {
        GETSTATIC("scala/collection/immutable/List$", "MODULE$", "Lscala/collection/immutable/List$;")
        GETSTATIC("scala/Predef$", "MODULE$", "Lscala/Predef$;")
        pushInt(sensitivityList.size)
        ANEWARRAY(p(classOf[AbstractSignal[_]]))
        for ((signal, i) <- sensitivityList.zipWithIndex) {
          DUP
          pushInt(i)
          ALOAD(0)
          GETFIELD(context.cw.className, signal.name, ci(classOf[AbstractSignal[_]]))
          AASTORE
        }
        CHECKCAST("[Ljava/lang/Object;")
        INVOKEVIRTUAL("scala/Predef$", "wrapRefArray", "([Ljava/lang/Object;)Lscala/collection/mutable/WrappedArray;")
        INVOKEVIRTUAL("scala/collection/immutable/List$", "apply", "(Lscala/collection/Seq;)Lscala/collection/immutable/List;")
      }
      ARETURN
      endMethod
    }

    def visitProcessStatement(processStmt: ProcessStatement, context: Context): Unit = {

      val processName = processStmt.symbol.name
      //TODO createGetSensitivityList(context, processName, processStmt.symbol.sensitivityList)
      val className = context.cw.className + "$" + processName

      context.cw.visitInnerClass(className, context.cw.className, processName, Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC)
      val cw = createClass(Opcodes.ACC_FINAL + Opcodes.ACC_SYNTHETIC, className, "java/lang/Object", if (processStmt.postponed) classOf[PostponedProcessAnnotation] else classOf[ProcessAnnotation], createEmptyConstructor = false)
      cw.visitInnerClass(className, context.cw.className, processName, Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC)
      cw.visitField(Opcodes.ACC_PRIVATE + Opcodes.ACC_FINAL, "architecture", "L" + context.cw.className + ";")

      {
        val mv = cw.createMethod(name = "<init>", parameters = "L" + context.cw.className + ";")
        val startLabel = RichLabel(mv)
        val endLabel = RichLabel(mv)
        import mv._

        startLabel()
        ALOAD(0)
        INVOKESPECIAL("java/lang/Object", "<init>", "()V")
        ALOAD(0)
        ALOAD(1)
        PUTFIELD(cw.className, "architecture", "L" + context.cw.className + ";")
        RETURN
        endLabel()
        visitLocalVariable("this", cw.className, null, startLabel, endLabel, 0)
        visitLocalVariable("architecture", context.cw.className, null, startLabel, endLabel, 1)
        endMethod
      }

      initItems(context.designUnit, 0, "init", processStmt.declarativeItems, cw)

      {
        val mv = cw.createMethod(name = "run")
        val continueLabel = RichLabel(mv)
        import mv._

        continueLabel()
        acceptList(processStmt.sequentialStatementList, Context(cw = cw, mv = mv, loopLabels = Map(), designUnit = context.designUnit))
        GOTO(continueLabel) //infinite loop
        RETURN
        endMethod
      }
      cw.writeToFile
    }

    def visitSignalAssignmentStatement(signalAssignStmt: SignalAssignmentStatement, context: Context): Unit = {
      // TODO Auto-generated method stub
      import context._

      mv.createDebugLineNumberInformation(signalAssignStmt)
      throw new UnsupportedOperationException()
    }

    def loadDefaultValue(dataType: DataType, mv: RichMethodVisitor): Unit = {
      import mv._

      dataType match {
        case scalarType: ScalarType => pushAnyVal(scalarType.left)
        //case enumType: EnumerationType => GETSTATIC(enumType.fullName(), enumType.elements.head.replace("\'", ""), getJVMDataType(enumType))
        /*case constrainedArrayType: ConstrainedArrayType =>
          constrainedArrayType.dimensions.map {
            dim =>
              pushInt((dim.from - dim.to).abs)
              pushInt(dim.from)
              pushInt(dim.to)
          }
          val name = getJVMName(constrainedArrayType)
          INVOKESTATIC(RUNTIME, "create" + name.split("/").last, "(" + ("I" * (3 * constrainedArrayType.dimensions.size)) + ")" + "L" + name + ";")
        case unconstrainedArrayType: UnconstrainedArrayType => ACONST_NULL //TODO
        */
        case arrayType: ArrayType => ACONST_NULL //TODO
        case record: RecordType =>
          NEW(record.fullName())
          DUP
          INVOKESPECIAL(record.fullName(), "<init>", "()V")
        case _: AccessType => ACONST_NULL
        case protectedType: ProtectedType =>
          NEW(protectedType.name)
          DUP
          INVOKESPECIAL(protectedType.fullName(), "<init>", "()V")
      }
    }

    def initSymbols(symbols: Seq[RuntimeSymbol], context: Context)(f: (RuntimeSymbol) => Unit): Unit = {
      import context._

      for (symbol <- symbols) {
        symbol.owner match {
          case _: SubprogramSymbol | _: PackageBodySymbol | _: PackageHeaderSymbol =>
          case _ => mv.ALOAD(0)
        }
        f(symbol)
        mv.storeSymbol(symbol)
      }
    }

    def visitVariableDeclaration(variableDeclaration: VariableDeclaration, context: Context): Unit =
      initSymbols(variableDeclaration.symbols, context) {
        symbol =>
          import context._

          variableDeclaration.initialValueExpression match {
            case Some(expression) => acceptExpression(expression, mv)
            case None =>
              mv.createDebugLineNumberInformation(variableDeclaration)
              loadDefaultValue(symbol.dataType, mv)
          }
      }

    def visitSignalDeclaration(signalDeclaration: SignalDeclaration, context: Context): Unit =
      error("not implemented") //initSymbols(signalDeclaration.symbols, context)

    def visitConstantDeclaration(constantDeclaration: ConstantDeclaration, context: Context): Unit =
      constantDeclaration.defaultExpression.foreach {
        defaultExpression =>
          initSymbols(constantDeclaration.symbols, context)(symbol => acceptExpression(defaultExpression, context.mv))
      }

    def visitFileDeclaration(fileDeclaration: FileDeclaration, context: Context): Unit = {
      import context._

      mv.createDebugLineNumberInformation(fileDeclaration.identifierList.head)
      initSymbols(fileDeclaration.symbols, context) {
        symbol =>
          mv.NEW(getJVMName(symbol))
          mv.DUP
          mv.INVOKESPECIAL(getJVMName(symbol), "<init>", "()V")
      }
      if (fileDeclaration.fileLogicalName.isDefined) {
        fileDeclaration.symbols.foreach {
          symbol =>
            mv.loadSymbol(symbol)
            acceptExpressionOption(fileDeclaration.fileLogicalName, mv)
            acceptExpressionOption(fileDeclaration.fileOpenKindExpression, mv)
            mv.INVOKESTATIC(RUNTIME, "file_open", "(" + ci(classOf[RuntimeFile]) + "Ljava/lang/String;" + (if (fileDeclaration.fileLogicalName.isDefined) "I" else "") + ")V")
        }
      }
    }

    def visitTypeDeclaration(typeDeclaration: AbstractTypeDeclaration, context: Context): Unit = {
      typeDeclaration.dataType match {
        case record: RecordType =>
          val className = context.cw.className + "$" + record.name
          context.cw.visitInnerClass(className, context.cw.className, record.name, Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC)
          val cw = createClass(Opcodes.ACC_FINAL, className, "java/lang/Object", classOf[RecordAnnotation], createEmptyConstructor = false)
          cw.visitInnerClass(className, context.cw.className, record.name, Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC)

          val methodDesc = record.elementList.map(element => getJVMDataType(element._2)).mkString
          for ((name, dataType) <- record.elementList) {
            cw.visitField(Opcodes.ACC_PUBLIC, name, getJVMDataType(dataType))
          }
          {
            val mv = cw.createMethod(name = "<init>", parameters = methodDesc, returnType = "V")
            import mv._

            ALOAD(0)
            INVOKESPECIAL("java/lang/Object", "<init>", "()V")
            for (((fieldName, fieldDataType), i) <- record.elementList.zip(record.elementList.map(element => getNextIndex(element._2)).scanLeft(1)(_ + _))) {
              ALOAD(0)
              loadInstruction(fieldDataType, i)
              PUTFIELD(record.fullName(), fieldName, getJVMDataType(fieldDataType))
            }
            RETURN
            endMethod
          }
          {
            val mv = cw.createMethod(name = "<init>")
            import mv._

            ALOAD(0)
            INVOKESPECIAL("java/lang/Object", "<init>", "()V")
            for ((fieldName, fieldDataType) <- record.elementList) {
              ALOAD(0)
              loadDefaultValue(fieldDataType, mv)
              PUTFIELD(record.fullName(), fieldName, getJVMDataType(fieldDataType))
            }
            RETURN
            endMethod
          }
          //generates code for canEqual and equals as described by M. Odersky in this article http://www.artima.com/lejava/articles/equality.html
          {
            /*
            generates this code:
               public boolean canEqual(Object other) {
                   return (other instanceof ClassName);
               }
            */
            val mv = cw.createMethod(name = "canEqual", parameters = "Ljava/lang/Object;", returnType = "Z")
            val startLabel = RichLabel(mv)
            val endLabel = RichLabel(mv)
            import mv._
            startLabel()
            ALOAD(1)
            INSTANCEOF(record.fullName())
            IRETURN
            visitLocalVariable("this", "L" + record.fullName() + ";", null, startLabel, startLabel, 0)
            visitLocalVariable("other", "Ljava/lang/Object;", null, startLabel, endLabel, 1)
            endMethod
          }
          {
            /*
             generates this code:
             public boolean equals(Object other){
               if (other instanceof ClassName){
                 ClassName that=(ClassName)other;
                 return that.canEqual(this) && this.field1==that.field1 && this.field2==that.field2;
               }
               return false;
             }
            */
            val mv = cw.createMethod(name = "equals", parameters = "Ljava/lang/Object;", returnType = "Z")
            val startLabel = new RichLabel(mv)
            val thatScopeLabel = new RichLabel(mv)
            val afterIfStmtLabel = new RichLabel(mv)
            val falseLabel = new RichLabel(mv)
            val endLabel = new RichLabel(mv)
            import mv._
            startLabel()
            ALOAD(1)
            INSTANCEOF(record.fullName())
            IFEQ(afterIfStmtLabel)
            ALOAD(1)
            CHECKCAST(record.fullName())
            ASTORE(2)
            thatScopeLabel()
            ALOAD(2)
            ALOAD(0)
            INVOKEVIRTUAL(record.fullName(), "canEqual", "(Ljava/lang/Object;)Z")
            IFEQ(falseLabel)
            for ((fieldName, fieldType) <- record.elementList) {
              ALOAD(0)
              GETFIELD(record.fullName(), fieldName, getJVMDataType(fieldType))
              ALOAD(2)
              GETFIELD(record.fullName(), fieldName, getJVMDataType(fieldType))
              (fieldType: @unchecked) match {
                case _: IntegerType | _: EnumerationType => IF_ICMPNE(falseLabel)
                case _: RealType =>
                  DCMPL
                  IFNE(falseLabel)
                case _: PhysicalType =>
                  LCMP
                  IFNE(falseLabel)
                case _: AccessType => IF_ACMPNE(falseLabel)
                case recordType: RecordType =>
                  INVOKEVIRTUAL(recordType.fullName(), "equals", "(Ljava/lang/Object;)Z")
                  IFEQ(falseLabel)
                case arrayType: ArrayType =>
                  INVOKESTATIC("java/util/Arrays", "equals", "(" + (getJVMDataType(arrayType) * 2) + ")Z")
                  IFEQ(falseLabel)
              }
            }
            ICONST_1
            IRETURN
            falseLabel()
            ICONST_0
            IRETURN
            afterIfStmtLabel()
            ICONST_0
            IRETURN
            endLabel()
            visitLocalVariable("this", "L" + record.fullName() + ";", null, startLabel, endLabel, 0)
            visitLocalVariable("other", "Ljava/lang/Object;", null, startLabel, endLabel, 1)
            visitLocalVariable("that", "L" + record.fullName() + ";", null, thatScopeLabel, afterIfStmtLabel, 2)
            endMethod
          }
          cw.writeToFile
        case enumType: EnumerationType =>
          val className = context.cw.className + "$" + enumType.name
          context.cw.visitInnerClass(className, context.cw.className, enumType.name, Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC)
          val cw = createClass(Opcodes.ACC_FINAL, className, "java/lang/Object", classOf[EnumerationAnnotation], Array(Type.getInternalName(classOf[EnumType])))
          cw.visitInnerClass(className, context.cw.className, enumType.name, Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC)

          cw.visitField(Opcodes.ACC_PRIVATE + Opcodes.ACC_FINAL + Opcodes.ACC_STATIC, "valuesArray", "[Ljava/lang/String;")
          val dataType = getJVMDataType(enumType)
          for ((enumValueName, index) <- enumType.elements.zipWithIndex) {
            cw.visitField(Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_STATIC, enumValueName.replace("\'", ""), dataType, null, index)
          }
          {
            val mv = cw.createMethod(name = "<clinit>")
            import mv._

            pushInt(enumType.elements.size)
            ANEWARRAY("java/lang/String")
            for ((enumValueName, index) <- enumType.elements.zipWithIndex) {
              DUP
              pushInt(index)
              LDC(enumValueName.replace("\'", ""))
              AASTORE
            }
            PUTSTATIC(enumType.fullName(), "valuesArray", "[Ljava/lang/String;")

            RETURN
            endMethod
          }
          {
            val mv = cw.createMethod(flags = Opcodes.ACC_SYNTHETIC, name = "getValue", parameters = "I", returnType = "Ljava/lang/String;")
            import mv._

            ILOAD(1)
            INVOKESTATIC(enumType.fullName(), "image", "(I)Ljava/lang/String;")
            ARETURN
            endMethod
          }
          {
            val mv = cw.createMethod(flags = Opcodes.ACC_STATIC + Opcodes.ACC_SYNTHETIC, name = "value", parameters = "Ljava/lang/String;", returnType = "I")
            val labels = Array.tabulate(enumType.elements.size)(i => new Label())
            val defaultLabel = RichLabel(mv)
            import mv._

            val dataType = getJVMDataType(enumType)
            ALOAD(0)
            if (enumType.elements.exists(_.contains("'"))) {
              LDC("\'")
              LDC("")
              INVOKEVIRTUAL("java/lang/String", "replace", "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;")
            }
            INVOKEVIRTUAL("java/lang/String", "hashCode", "()I")
            val values = enumType.elements.map(enumName => (enumName.hashCode, enumName)).zipWithIndex.sortBy(x => x._1._1)

            LOOKUPSWITCH(defaultLabel, values.map(_._1._1).toArray, labels)
            for (((_, enumName), i) <- values) {
              visitLabel(labels(i))
              GETSTATIC(enumType.fullName(), enumName.replace("\'", ""), dataType)
              IRETURN
            }
            defaultLabel()
            throwNewException(p(classOf[VHDLRuntimeException]), "invalid enum string")
            endMethod
          }
          {
            /*        generates code equivalent to
                      def checkIsInRange(value: Int, low: Int, high: Int): Int = {
                      if (value < low || value > high) throw new VHDLRuntimeException("value:" + image(value) + " is out of range " + image(low) + " to " + image(high))
                      value
                      }
            */
            val mv = cw.createMethod(flags = Opcodes.ACC_STATIC + Opcodes.ACC_SYNTHETIC, name = "checkIsInRange", parameters = "III", returnType = "I")
            val throwLabel = RichLabel(mv)
            val returnLabel = RichLabel(mv)
            import mv._

            ILOAD(0)
            ILOAD(1)
            IF_ICMPLT(throwLabel)
            ILOAD(0)
            ILOAD(2)
            IF_ICMPLE(returnLabel)
            throwLabel()
            NEW(p(classOf[VHDLRuntimeException]))
            DUP
            NEW("java/lang/StringBuilder")
            DUP
            LDC("value:")
            INVOKESPECIAL("java/lang/StringBuilder", "<init>", "(Ljava/lang/String;)V")
            ILOAD(0)
            INVOKESTATIC(enumType.fullName(), "image", "(I)Ljava/lang/String;")
            INVOKEVIRTUAL("java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;")
            LDC(" is out of range ")
            INVOKEVIRTUAL("java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;")
            ILOAD(1)
            INVOKESTATIC(enumType.fullName(), "image", "(I)Ljava/lang/String;")
            INVOKEVIRTUAL("java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;")
            LDC(" to ")
            INVOKEVIRTUAL("java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;")
            ILOAD(2)
            INVOKESTATIC(enumType.fullName(), "image", "(I)Ljava/lang/String;")
            INVOKEVIRTUAL("java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;")
            INVOKEVIRTUAL("java/lang/StringBuilder", "toString", "()Ljava/lang/String;")
            INVOKESPECIAL(p(classOf[VHDLRuntimeException]), "<init>", "(Ljava/lang/String;)V")
            ATHROW
            returnLabel()
            ILOAD(0)
            IRETURN
            endMethod
          }
          {
            val mv = cw.createMethod(flags = Opcodes.ACC_STATIC + Opcodes.ACC_SYNTHETIC, name = "image", parameters = "I", returnType = "Ljava/lang/String;")
            import mv._

            GETSTATIC(enumType.fullName(), "valuesArray", "[Ljava/lang/String;")
            ILOAD(0)
            AALOAD
            ARETURN
            endMethod
          }
          cw.writeToFile
        case _ => typeDeclaration match {
          case protectedTypeBody: ProtectedTypeBodyDeclaration =>
            val className = context.cw.className + "$" + protectedTypeBody.identifier.text
            context.cw.visitInnerClass(className, context.cw.className, protectedTypeBody.identifier.text, Opcodes.ACC_PUBLIC)
            val cw = createClass(Opcodes.ACC_FINAL, className, "java/lang/Object", classOf[ProtectedTypeBodyAnnotation], createEmptyConstructor = false)
            cw.visitInnerClass(className, context.cw.className, protectedTypeBody.identifier.text, Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC)
            val mv = cw.createMethod(name = "<init>")
            mv.visitCode
            mv.ALOAD(0)
            mv.INVOKESPECIAL("java/lang/Object", "<init>", "()V")
            initItems(context.designUnit, 0, "<init>", protectedTypeBody.declarativeItems, cw, Some(mv))
            mv.RETURN
            mv.endMethod
            cw.writeToFile
          case _ =>
        }
      }
    }

    def loadParameters(parameters: Seq[Expression], mv: RichMethodVisitor): Unit = {
      //TODO check if values are in subType (call checkIsInRange)
      //it is an error if, after applying any conversion function or type conversion present in the actual part of the applicable association element (see 4.3.2.2), the value of the actual parameter
      //does not belong to the subtype denoted by the subtype indication of the formal.
      parameters.foreach(acceptExpression(_, mv))
    }

    def createClass(flags: Int, name: String, superClass: String, annotationClass: Class[_], interfaces: Array[String] = null, createEmptyConstructor: Boolean = true): RichClassWriter = {
      import java.io.File

      val cw = if (configuration.debugCodeGenerator) {
        import org.objectweb.asm.util.TraceClassVisitor
        import java.io.PrintWriter

        val cw = new ClassWriter(0)
        val tcv = new TraceClassVisitor(cw, new PrintWriter(System.out, true))
        //new RichClassWriter(configuration.designLibrary + File.separator, name, cw,Some(new CheckClassAdapter(tcv)))
        new RichClassWriter(configuration.designLibrary + File.separator, name, cw, Some(tcv))
      } else {
        new RichClassWriter(configuration.designLibrary + File.separator, name, new ClassWriter(ClassWriter.COMPUTE_FRAMES + ClassWriter.COMPUTE_MAXS))
      }

      cw.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC + Opcodes.ACC_SUPER + flags, name, null, superClass, interfaces)
      cw.visitAnnotation(Type.getDescriptor(annotationClass), true)
      cw.visitSource(sourceFileName, OpenVCSignature)
      if (createEmptyConstructor) cw.createEmptyConstructor()
      cw
    }
  }
}