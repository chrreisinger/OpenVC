/*
 *     OpenVC, an open source VHDL compiler/simulator
 *     Copyright (C) 2010  Christian Reisinger
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package at.jku.ssw.openvc.backend.jvm

import org.objectweb.asm.{ClassWriter, Label, Opcodes, Type}

import at.jku.ssw.openvc._
import util._
import ast._
import ast.concurrentStatements._
import ast.sequentialStatements._
import ast.designUnits._
import ast.declarativeItems._
import ast.expressions._
import symbolTable._
import symbols._
import dataTypes._
import VHDLCompiler.Configuration

import at.jku.ssw.openvs.RuntimeAnnotations._
import at.jku.ssw.openvs.VHDLRuntime
import at.jku.ssw.openvs.VHDLRuntime.{EnumerationType => EnumerationTypeInterface, RecordType => RecordTypeInterface, ArrayType => _, _}

//opcodes currently not used: jsr,monitorenter,monitorexit,pop2,ret,swap
object ByteCodeGenerator {
  //remove $ from class name
  val RUNTIME = p(VHDLRuntime.getClass).init
  //something like at/jku/ssw/openvc , without VHDLRuntime
  val OPENVS = RUNTIME.substring(0, RUNTIME.lastIndexOf('/') + 1)
  private val OpenVCSignature = "generated by OpenVC 0.01"

  private final class LoopLabels(val continueLabel: RichLabel, val breakLabel: RichLabel)

  private final case class Context(cw: RichClassWriter, mv: RichMethodVisitor = null, loopLabels: Map[Position, LoopLabels] = Map(), designUnit: String = "", fileSymbols: Seq[FileSymbol] = Seq()) {
    def insertLoopLabels(position: Position, loopLabels: LoopLabels): Context = this.copy(loopLabels = this.loopLabels + (position -> loopLabels))

    implicit val implicitCW = cw
    implicit val implicitMV = mv
  }

  private object ExpressionContext {

    object JumpKind extends Enumeration {
      val TrueJump, FalseJump = Value
    }

  }

  private final case class ExpressionContext(trueJumpLabel: RichLabel, falseJumpLabel: RichLabel, kind: ExpressionContext.JumpKind.Value) {
    def invert: ExpressionContext = {
      val newKind = kind match {
        case ExpressionContext.JumpKind.TrueJump => ExpressionContext.JumpKind.FalseJump
        case ExpressionContext.JumpKind.FalseJump => ExpressionContext.JumpKind.TrueJump
      }
      ExpressionContext(trueJumpLabel = falseJumpLabel, falseJumpLabel = trueJumpLabel, kind = newKind)
    }
  }

  private def getJVMParameterList(list: Seq[RuntimeSymbol]): String = list.map(getJVMDataType).mkString

  private def p(n: Class[_]): String = n.getName.replace('.', '/')

  private def ci(n: Class[_]): String = "L" + p(n) + ";"

  def getBoxedType(dataType: DataType): String = "L" + getBoxedName(dataType) + ";"

  def getBoxedName(dataType: DataType): String = (dataType: @unchecked) match {
    case _: IntegerType => p(classOf[java.lang.Integer])
    case _: RealType => p(classOf[java.lang.Double])
    case _: PhysicalType => p(classOf[java.lang.Long])
    case enumeration: EnumerationType =>
      if (enumeration == SymbolTable.booleanType || enumeration == SymbolTable.bitType) p(classOf[java.lang.Boolean])
      else if (enumeration.elements.size <= Byte.MaxValue) p(classOf[java.lang.Byte])
      else p(classOf[java.lang.Character])
  }

  def getMutableScalarAccessType(scalarType: ScalarType): String = "L" + getMutableScalarAccessName(scalarType) + ";"

  def getMutableScalarAccessName(scalarType: ScalarType): String = scalarType match {
    case _: IntegerType => p(classOf[MutableInteger])
    case _: RealType => p(classOf[MutableReal])
    case _: PhysicalType => ci(classOf[MutableLong])
    case enumeration: EnumerationType =>
      if (enumeration == SymbolTable.booleanType || enumeration == SymbolTable.bitType) p(classOf[MutableBoolean])
      else if (enumeration.elements.size <= Byte.MaxValue) p(classOf[MutableByte])
      else p(classOf[MutableCharacter])
  }

  def getJVMDataType(symbol: RuntimeSymbol): String = symbol match {
    case signal: SignalSymbol => ci(classOf[AbstractSignal[_]])
    case _ => getJVMDataType(symbol.dataType)
  }

  def getScalaSpecializedClassSuffix(dataType: DataType): String = (dataType: @unchecked) match {
    case _: IntegerType => "mcI$sp"
    case _: RealType => "mcD$sp"
    case _: PhysicalType => "mcL$sp"
    case enumeration: EnumerationType =>
      if (enumeration == SymbolTable.booleanType || enumeration == SymbolTable.bitType) "mcZ$sp"
      else if (enumeration.elements.size <= Byte.MaxValue) "mcB$sp"
      else "mcC$sp"
    case _ => ""
  }

  def getScalaSpecializedMethodSuffix(dataType: DataType): String = (dataType: @unchecked) match {
    case _: IntegerType => "mIc$sp"
    case _: RealType => "mDc$sp"
    case _: PhysicalType => "mLc$sp"
    case enumeration: EnumerationType =>
      if (enumeration == SymbolTable.booleanType || enumeration == SymbolTable.bitType) "mZc$sp"
      else if (enumeration.elements.size <= Byte.MaxValue) "mBc$sp"
      else "mCc$sp"
    case _ => ""
  }

  def getJVMDataType(dataType: DataType): String = (dataType: @unchecked) match {
    case _: IntegerType => "I"
    case _: RealType => "D"
    case _: PhysicalType => "J"
    case enumeration: EnumerationType =>
      if (enumeration == SymbolTable.booleanType || enumeration == SymbolTable.bitType) "Z"
      else if (enumeration.elements.size <= Byte.MaxValue) "B"
      else "C"
    //case arrayType: ConstrainedArrayType => ("[" * arrayType.dimensions.size) + getJVMDataType(arrayType.elementType)
    //case _: UnconstrainedArrayType => "L" + getJVMName(dataType) + ";"
    case _: ArrayType => "L" + getJVMName(dataType) + ";"
    case hasOwner: HasOwner => "L" + hasOwner.implementationName + ";" //handles RecordType and ProtectedType
    case _: FileType | _: RangeType => "L" + getJVMName(dataType) + ";"
    case accessType: AccessType =>
      accessType.pointerType match {
        case scalarType: ScalarType => getMutableScalarAccessType(scalarType)
        case otherType => getJVMDataType(otherType)
      }
  }

  def getJVMName(symbol: RuntimeSymbol): String = symbol match {
    case signal: SignalSymbol => p(classOf[AbstractSignal[_]])
    case _ => getJVMName(symbol.dataType)
  }

  private def doBox(scalarType: ScalarType)(implicit mv: RichMethodVisitor) = mv.INVOKESTATIC(getBoxedName(scalarType), "valueOf", "(" + getJVMDataType(scalarType) + ")" + getBoxedType(scalarType))

  private def doUnBox(scalarType: ScalarType)(implicit mv: RichMethodVisitor) = {
    val method = scalarType match {
      case _: IntegerType => "intValue"
      case _: RealType => "doubleValue"
      case _: PhysicalType => "longValue"
      case enumeration: EnumerationType =>
        if (enumeration == SymbolTable.booleanType || enumeration == SymbolTable.bitType) "booleanValue"
        else if (enumeration.elements.size <= Byte.MaxValue) "byteValue"
        else "charValue"
    }
    mv.INVOKEVIRTUAL(getBoxedName(scalarType), method, "()" + getJVMDataType(scalarType))
  }

  def getJVMName(dataType: DataType): String = dataType match {
    case arrayType: ArrayType =>
      if (dataType == SymbolTable.stringType) "java/lang/String"
      else OPENVS + "VHDLRuntime$RuntimeArray" + arrayType.dimensions.size + "D$" + getScalaSpecializedClassSuffix(arrayType.elementType)
    case accessType: AccessType =>
      accessType.pointerType match {
        case scalarType: ScalarType => getMutableScalarAccessName(scalarType)
        case otherType => getJVMName(otherType)
      }
    case _: RangeType => p(classOf[scala.Range.Inclusive])
    case hasOwner: HasOwner => hasOwner.implementationName
    case fileType: FileType => p(classOf[RuntimeFile])
  }

  def getJVMArrayType(dataType: ScalarType): Int = dataType match {
    case _: IntegerType => Opcodes.T_INT
    case _: RealType => Opcodes.T_DOUBLE
    case _: PhysicalType => Opcodes.T_LONG
    case enumeration: EnumerationType =>
      if (enumeration == SymbolTable.booleanType || enumeration == SymbolTable.bitType) Opcodes.T_BOOLEAN
      else if (enumeration.elements.size <= Byte.MaxValue) Opcodes.T_BYTE
      else Opcodes.T_CHAR
  }

  def getNextIndex(dataType: DataType): Int = dataType match {
    case _: RealType | _: PhysicalType => 2
    case _ => 1
  }

  def apply(configuration: Configuration, sourceFileName: String, designFile: ASTNode) {
    acceptNode(designFile, null)

    def acceptNodes(nodes: Seq[ASTNode], context: Context) {for (node <- nodes) acceptNode(node, context)}

    def acceptNode(node: ASTNode, context: Context) {
      node match {
        case DesignFile(designUnits) => acceptNodes(designUnits, context)
        case designUnit: DesignUnit => designUnit.libraryUnit.foreach(acceptNode(_, context))
        case packageBodyDeclaration: PackageBodyDeclaration => visitPackageBodyDeclaration(packageBodyDeclaration)
        case packageDeclaration: PackageDeclaration => visitPackageDeclaration(packageDeclaration)
        case entityDeclaration: EntityDeclaration => visitEntityDeclaration(entityDeclaration)
        case architectureDeclaration: ArchitectureDeclaration => visitArchitectureDeclaration(architectureDeclaration)
        case configurationDeclaration: ConfigurationDeclaration => visitConfigurationDeclaration(configurationDeclaration)
        //concurrent Statements
        case componentInstantiationStmt: ComponentInstantiationStatement => visitComponentInstantiationStatement(componentInstantiationStmt)
        case processStmt: ProcessStatement => visitProcessStatement(processStmt, context)
        case blockStmt: BlockStatement => visitBlockStatement(blockStmt, context)
        //sequential Statements
        case throwStatement: ThrowStatement =>
          context.mv.createDebugLineNumberInformation(throwStatement)
          context.mv.throwNewException(p(classOf[VHDLRuntimeException]), throwStatement.message)
        case assertStmt: AssertionStatement => visitAssertionStatement(assertStmt, context)
        case waitStmt: WaitStatement => visitWaitStatement(waitStmt, context)
        case nextStmt: NextStatement => visitNextStatement(nextStmt, context)
        case exitStmt: ExitStatement => visitExitStatement(exitStmt, context)
        case nullStmt: NullStatement =>
          context.mv.createDebugLineNumberInformation(nullStmt)
          context.mv.NOP()
        case reportStmt: ReportStatement => visitReportStatement(reportStmt, context)
        case returnStmt: ReturnStatement => visitReturnStatement(returnStmt, context)
        case loopStmt: LoopStatement => visitLoopStatement(loopStmt, context)
        case whileStmt: WhileStatement => visitWhileStatement(whileStmt, context)
        case forStmt: ForStatement => visitForStatement(forStmt, context)
        case signalAssignmentStmt: SignalAssignmentStatement => visitSignalAssignmentStatement(signalAssignmentStmt, context)
        case variableAssignmentStmt: VariableAssignmentStatement => visitVariableAssignmentStatement(variableAssignmentStmt, context)
        case procedureCallStmt: ProcedureCallStatement => visitProcedureCallStatement(procedureCallStmt, context)
        case caseStmt: CaseStatement => visitCaseStatement(caseStmt, context)
        case ifStmt: IfStatement => visitIfStatement(ifStmt, context)
        //declarative Items
        case variableDeclaration: VariableDeclaration => visitVariableDeclaration(variableDeclaration, context)
        case constantDeclaration: ConstantDeclaration => visitConstantDeclaration(constantDeclaration, context)
        case signalDeclaration: SignalDeclaration => visitSignalDeclaration(signalDeclaration, context)
        case fileDeclaration: FileDeclaration => visitFileDeclaration(fileDeclaration, context)
        case typeDeclaration: AbstractTypeDeclaration => visitTypeDeclaration(typeDeclaration, context)
        case functionDefinition: FunctionDefinition => visitFunctionDefinition(functionDefinition, context)
        case procedureDefinition: ProcedureDefinition => visitProcedureDefinition(procedureDefinition, context)
        case componentDeclaration: ComponentDeclaration => visitComponentDeclaration(componentDeclaration, context)
        case aliasDeclaration: AliasDeclaration => visitAliasDeclaration(aliasDeclaration, context)
        case _: GenerateStatement | _: FunctionDeclaration | _: ProcedureDeclaration | _: SubTypeDeclaration | _: AttributeDeclaration | _: AttributeSpecification | _: GroupTemplateDeclaration | _: GroupDeclaration | _: UseClause | _: ContextDeclaration => //nothing
      }
    }

    def acceptExpressionOption(expr: Option[Expression], contextOption: Option[ExpressionContext] = None, createDebugLineNumberInformation: Boolean = true)(implicit mv: RichMethodVisitor) =
      expr.foreach(acceptExpression(_, contextOption, createDebugLineNumberInformation))

    def acceptExpression(expr: Expression, contextOption: Option[ExpressionContext] = None, createDebugLineNumberInformation: Boolean = true)(implicit mv: RichMethodVisitor) {
      if (createDebugLineNumberInformation) mv.createDebugLineNumberInformation(expr)

      def toRelation(expr: Expression) = expr match {
        case _: LogicalExpression | _: Relation | _: Factor | NoExpression => expr
        case _ => Relation(expr.position, expr, Relation.Operator.NEQ, NoExpression, expr.dataType)
      }

      contextOption match {
        case Some(context) => acceptExpressionInner(toRelation(expr), context)
        case None =>
          expr.dataType match {
            case e: EnumerationType if (e == SymbolTable.booleanType || e == SymbolTable.bitType) =>
              expr match {
                case _: LogicalExpression | _: Relation =>
                  import mv._
                  val trueLabel = createLabel
                  val falseLabel = createLabel
                  val afterLabel = createLabel
                  acceptExpressionInner(expr, ExpressionContext(trueLabel, falseLabel, ExpressionContext.JumpKind.TrueJump))

                  falseLabel()
                  ICONST_0
                  GOTO(afterLabel)
                  trueLabel()
                  ICONST_1
                  afterLabel()
                case _ => acceptExpressionInner(expr)
              }
            case _ => acceptExpressionInner(expr)
          }
      }

      def acceptExpressionInnerOption(expression: Option[Expression], innerContext: ExpressionContext = null) {expression.foreach(acceptExpressionInner(_, innerContext))}

      def acceptExpressionInner(expression: Expression, innerContext: ExpressionContext = null) {
        expression match {
          case NoExpression => //nothing
          case term: Term => visitTerm(term)
          case aggregate: Aggregate => visitAggregate(aggregate)
          case typeCastExpr: TypeCastExpression => visitTypeCastExpression(typeCastExpr)
          case relation: Relation => visitRelation(relation, innerContext)
          case factor: Factor => visitFactor(factor, innerContext)
          case shiftExpression: ShiftExpression =>
            acceptExpressionInner(shiftExpression.left)
            acceptExpressionInner(shiftExpression.right)
            import ShiftExpression.Operator._
            import mv._
            val parameters = shiftExpression.operator match {
              case SLA | SRA =>
                //TODO is ascending? shiftExpression.dataType.asInstanceOf[ArrayType].dimensions
                ICONST_1
                "(" + getJVMDataType(shiftExpression.left.dataType) + "IZ)"
              case _ => "(" + getJVMDataType(shiftExpression.left.dataType) + "I)"
            }
            INVOKESTATIC(RUNTIME, shiftExpression.operator.toString, parameters + getJVMDataType(shiftExpression.left.dataType))
          case DefaultExpression(symbol) =>
            mv.INVOKESTATIC(symbol.owner.owner.implementationName, "$default$" + (symbol.owner match {
              case subprogram: SubprogramSymbol => subprogram.mangledName
              case s => s.name
            }) + "_" + symbol.name, "()" + getJVMDataType(symbol.dataType))
          case functionCallExpr: FunctionCallExpression => visitFunctionCallExpression(functionCallExpr)
          case logicalExpr: LogicalExpression =>
            logicalExpr.dataType match {
              case _: ArrayType => visitLogicalExpression(logicalExpr, innerContext)
              case _ => visitLogicalExpression(logicalExpr.copy(left = toRelation(logicalExpr.left), right = toRelation(logicalExpr.right)), innerContext)
            }
          case simpleExpr: SimpleExpression => visitSimpleExpression(simpleExpr)
          case newExpr: NewExpression => visitNewExpression(newExpr)
          case literal: Literal => visitLiteral(literal)
          case physicalLiteral: PhysicalLiteral => visitPhysicalLiteral(physicalLiteral)

          case ItemExpression(_, symbol) => mv.loadSymbol(symbol)
          case ArrayAccessExpression(symbol, indexes, elementType, expressionOption) =>
            import mv._
            loadSymbol(symbol)
            (symbol.dataType: @unchecked) match {
              case constrainedArrayType: ConstrainedArrayType =>
                for (((expr, i), dim) <- indexes.zipWithIndex.zip(constrainedArrayType.dimensions)) {
                  acceptExpressionInner(expr, innerContext)
                  if (dim.from != 0) {
                    pushInt(dim.from)
                    pushInt(dim.to)
                    INVOKESTATIC(RUNTIME, "getArrayIndex1D", "(III)I")
                  }
                  indexes.size - 1 - i match {
                    case 0 => arrayLoadInstruction(constrainedArrayType.elementType)
                    case _ => AALOAD()
                  }
                }
              case unconstrainedArrayType: UnconstrainedArrayType =>
                indexes.foreach(acceptExpressionInner(_, innerContext))
                unconstrainedArrayType.elementType match {
                  case _: RecordType =>
                    INVOKEVIRTUAL(getJVMName(symbol), "getValue", "(" + ("I" * indexes.size) + ")" + "Ljava/lang/Object;")
                    CHECKCAST(getJVMName(unconstrainedArrayType.elementType))
                  case _ => INVOKEVIRTUAL(getJVMName(symbol), "getValue", "(" + ("I" * indexes.size) + ")" + getJVMDataType(unconstrainedArrayType.elementType))
                }
            }
            expressionOption.foreach(acceptExpressionInner(_, innerContext))
          case attributeAccess: AttributeExpression => visitAttributeAccessExpression(attributeAccess)
          case FieldAccessExpression(symbol, field, fieldDataType, expressionOption) =>
            import mv._
            if (symbol.owner != NoSymbol && !symbol.owner.isInstanceOf[RuntimeSymbol]) loadSymbol(symbol)
            GETFIELD(symbol.dataType.implementationName, field.text, getJVMDataType(fieldDataType))
            expressionOption.foreach(acceptExpressionInner(_, innerContext))
          case e =>
            println(e.getClass.getName + " " + e.position)
            throw new IllegalArgumentException()
        }
      }

      def visitAttributeAccessExpression(attributeAccess: AttributeExpression) {
        attributeAccess.attribute match {
          case preDefinedAttributeSymbol: PreDefinedAttributeSymbol =>
            implicit val implicitMV = mv
            import mv._
            attributeAccess.symbol match {
              case _: TypeSymbol | _: SubTypeSymbol =>
                ((attributeAccess.symbol: @unchecked) match {
                  case typeSymbol: TypeSymbol => typeSymbol.dataType
                  case subTypeSymbol: SubTypeSymbol => subTypeSymbol.dataType
                }) match {
                  case scalarType: ScalarType =>
                    attributeAccess.attribute.name match {
                      case "left" => pushAnyVal(scalarType.left)
                      case "right" => pushAnyVal(scalarType.right)
                      case "low" => pushAnyVal(scalarType.lowerBound)
                      case "high" => pushAnyVal(scalarType.upperBound)
                      case "ascending" => pushBoolean(scalarType.isAscending)
                      case "image" =>
                        acceptExpressionOption(attributeAccess.parameterExpression)
                        scalarType match {
                          case _: IntegerType | _: RealType | _: PhysicalType => INVOKESTATIC(getBoxedName(scalarType), "toString", "(" + getJVMDataType(scalarType) + ")Ljava/lang/String;")
                          case enumType: EnumerationType => INVOKESTATIC(enumType.implementationName, "image", "(I)Ljava/lang/String;")
                        }
                      case "value" =>
                        acceptExpressionOption(attributeAccess.parameterExpression)
                        scalarType match {
                          case _: IntegerType => INVOKESTATIC("java/lang/Integer", "parseInt", "(Ljava/lang/String;)I")
                          case _: RealType => INVOKESTATIC("java/lang/Double", "parseDouble", "(Ljava/lang/String;)D")
                          case _: PhysicalType => INVOKESTATIC("java/lang/Long", "parseLong", "(Ljava/lang/String;)L")
                          case enumType: EnumerationType => INVOKESTATIC(enumType.implementationName, "value", "(Ljava/lang/String;)I")
                        }
                      case "base" => //nothing
                      case "pos" | "val" | "succ" | "leftof" | "rightof" =>
                        error("not implemented")
                      /*scalarType match {
                        case _: IntegerType => mv.INVOKESTATIC(RUNTIME, attributeAccess.attribute.name, "(I)I")
                        case _: RealType => mv.INVOKESTATIC(RUNTIME, attributeAccess.attribute.name, "(D)D")
                        case enumType: EnumerationType => mv.INVOKESTATIC(enumType.implementationName(), attributeAccess.attribute.name, "(I)I")
                      }*/
                    }
                }
              case signal: SignalSymbol if (signal.attributes.contains(attributeAccess.attribute.name)) =>
                loadSymbol(signal)
                acceptExpressionOption(attributeAccess.parameterExpression)
                //"delayed" | "stable" | "quiet" | "transaction" | "event" | "active" | "last_event" | "last_active" | "last_value" | "driving" | "event" | "driving_value"
                INVOKEVIRTUAL(getJVMName(signal), attributeAccess.attribute.name, if (preDefinedAttributeSymbol.parameter.isDefined) "(L)" else "()" + getJVMDataType(attributeAccess.attribute.dataType))
              case symbol: RuntimeSymbol =>
                symbol.dataType match {
                  case arrayType: ArrayType =>
                    loadSymbol(symbol)
                    attributeAccess.parameterExpression match {
                      case None => ICONST_1 //this must be a array attribute where the dimension is optional
                      case Some(parameterExpression) => acceptExpression(parameterExpression)
                    }
                    //"left" | "right" | "low" | "high" | "length" | "ascending" | "range" | "reverse_range"
                    INVOKEVIRTUAL(getJVMName(symbol), attributeAccess.attribute.name, "(I)" + getJVMDataType(attributeAccess.attribute.dataType))
                }
            }
          case userDefinedAttributeSymbol: UserDefinedAttributeSymbol => error("not implemented")
        }
        acceptExpressionOption(attributeAccess.expression)
      }

      def visitAggregate(aggregate: Aggregate) {
        implicit val implicitMV = mv
        import mv._
        (aggregate.dataType: @unchecked) match {
          case arrayType: ConstrainedArrayType =>
            pushInt(aggregate.expressions.size)
            arrayType.dimensions.size match {
              case 1 => arrayType.elementType match {
                case scalarType: ScalarType => NEWARRAY(getJVMArrayType(scalarType))
                case dataType => ANEWARRAY(getJVMName(dataType))
              }
              case size => ANEWARRAY(("[" * (size - 1)) + getJVMDataType(arrayType.elementType))
            }
            for ((expr, i) <- aggregate.expressions.zipWithIndex) {
              DUP
              pushInt(i)
              acceptExpression(expr)
              if (arrayType.dimensions.size == 1) arrayStoreInstruction(arrayType.elementType)
              else AASTORE
            }
          case recordType: RecordType =>
            NEW(recordType.implementationName)
            DUP
            for ((dataType, expr) <- recordType.fields.unzip._2.zip(aggregate.expressions)) {
              acceptExpressionInner(expr)
              checkIsInRange(dataType)
            }
            val desc = recordType.fields.map(field => getJVMDataType(field._2)).mkString
            INVOKESPECIAL(recordType.implementationName, "<init>", "(" + desc + ")V")
        }
      }

      def visitFactor(factor: Factor, context: ExpressionContext) {
        import Factor.Operator._
        import mv._

        factor.operator match {
          case POW =>
            acceptExpressionInner(factor.left, context)
            acceptExpressionInner(factor.rightOption.get, context)
            INVOKESTATIC(RUNTIME, "pow", "(" + getJVMDataType(factor.dataType) + "I)" + getJVMDataType(factor.dataType)) //calls pow(II)I or pow(DI)D
          case ABS =>
            require(factor.rightOption.isEmpty)
            acceptExpressionInner(factor.left, context)
            INVOKESTATIC("java/lang/Math", "abs", "(" + getJVMDataType(factor.dataType) + ")" + getJVMDataType(factor.dataType)) //calls abs(I)I or abs(D)D or abs(L)L
          case NOT =>
            require(factor.rightOption.isEmpty)
            factor.dataType match {
              case arrayType: ArrayType =>
                acceptExpressionInner(factor.left, context)
                INVOKESTATIC(RUNTIME, "NOT", "([Z)[Z")
              case _ => acceptExpressionInner(toRelation(factor.left), context.invert)
            }
        }
      }

      def visitFunctionCallExpression(functionCallExpr: FunctionCallExpression) {
        val functionSymbol = functionCallExpr.symbol
        functionSymbol.attributes.get("foreign") match {
          case Some(attributeSymbol) if (attributeSymbol.isInstanceOf[ForeignAttributeSymbol]) =>
            loadParameters(functionCallExpr.parameterAssociation)
            attributeSymbol.asInstanceOf[ForeignAttributeSymbol].jvmSignature match {
              case Left((className, methodName)) => mv.INVOKESTATIC(className, methodName, "(" + getJVMParameterList(functionSymbol.parameters) + ")V")
              case Right((className, methodName, parameterTypes)) => mv.INVOKESTATIC(className, methodName, parameterTypes)
            }
          case _ =>
            val functionCallType = if (functionSymbol.isStatic) Opcodes.INVOKESTATIC
            else {
              mv.ALOAD(0)
              Opcodes.INVOKEVIRTUAL
            }
            loadParameters(functionCallExpr.parameterAssociation)
            mv.visitMethodInsn(functionCallType, functionSymbol.owner.implementationName, functionSymbol.mangledName, "(" + getJVMParameterList(functionSymbol.parameters) + ")" + getJVMDataType(functionSymbol.returnType))
        }
        functionCallExpr.expression.foreach(acceptExpressionInner(_))
      }

      def visitPhysicalLiteral(physicalLiteral: PhysicalLiteral) {
        import Literal.Type._
        import mv._
        val dataType = physicalLiteral.dataType.asInstanceOf[PhysicalType]
        physicalLiteral.literalType match {
          case INTEGER_LITERAL => pushLong(physicalLiteral.toLong * dataType.units(physicalLiteral.unitSymbol.name))
          case REAL_LITERAL => pushLong((physicalLiteral.toDouble * dataType.units(physicalLiteral.unitSymbol.name)).toLong)
        }
      }

      def visitLiteral(literal: Literal) {
        import Literal.Type._
        import mv._

        literal.literalType match {
          case STRING_LITERAL =>
            if (literal.dataType == SymbolTable.stringType) LDC(literal.text)
            else {
              val dataType = literal.dataType.asInstanceOf[ArrayType].elementType.asInstanceOf[EnumerationType]
              pushInt(literal.text.length)
              NEWARRAY(getJVMArrayType(dataType))
              for ((c, i) <- literal.text.zipWithIndex) {
                DUP
                pushInt(i)
                pushInt(dataType.intValue(c.toString))
                arrayStoreInstruction(dataType)
              }
            }
          case INTEGER_LITERAL | REAL_LITERAL | CHARACTER_LITERAL => pushAnyVal(literal.value)
          case NULL_LITERAL => ACONST_NULL
        }
      }

      def visitNewExpression(newExpression: NewExpression) {
        newExpression.qualifiedExpressionOrSubTypeIndication match {
          case Left(qualifiedExpression) => acceptExpression(qualifiedExpression)
          case Right(subTypeIndication) =>
            import mv._
            val dataTypeName = getMutableScalarAccessName(newExpression.dataType.asInstanceOf[ScalarType])
            NEW(dataTypeName)
            DUP
            INVOKESPECIAL(dataTypeName, "<init>", "()V")
        }
      }

      def visitLogicalExpression(logicalExpr: LogicalExpression, context: ExpressionContext, lastXORStatement: Boolean = true) {
        import LogicalExpression.Operator._
        import ExpressionContext.JumpKind._

        logicalExpr.dataType match {
          case arrayType: ArrayType =>
            acceptExpressionInner(logicalExpr.left, context)
            acceptExpressionInner(logicalExpr.right, context)
            mv.INVOKESTATIC(RUNTIME, logicalExpr.operator.toString, "([Z[Z)[Z")
          case _ =>
            //AND,NAND,OR,NOR are short-circuit operators
            // AND,NAND left expr == false => jump
            // OR, NOR left expr == true => jump
            def acceptExprCreateBoolValue(expr: Expression) {
              import mv._
              val trueLabel = createLabel
              val falseLabel = createLabel
              val afterLabel = createLabel

              def createValues() {
                trueLabel()
                ICONST_1
                GOTO(afterLabel)
                falseLabel()
                ICONST_0
                afterLabel()
              }
              val newContext = ExpressionContext(trueLabel, falseLabel, FalseJump)
              expr match {
                case logicalExpression: LogicalExpression =>
                  logicalExpression.operator match {
                    case XOR | XNOR => visitLogicalExpression(logicalExpression, newContext, false)
                    case _ =>
                      visitLogicalExpression(logicalExpression, newContext, false)
                      createValues()
                  }
                case _ =>
                  acceptExpressionInner(expr, newContext)
                  createValues()
              }
            }
            def newFalseLabel(label: RichLabel): RichLabel =
              if ((logicalExpr.left.isInstanceOf[LogicalExpression]) || context.kind == FalseJump) context.falseJumpLabel
              else label

            def newTrueLabel(label: RichLabel): RichLabel =
              if ((logicalExpr.left.isInstanceOf[LogicalExpression]) || context.kind == TrueJump) context.trueJumpLabel
              else label

            import mv._
            val afterLabel = createLabel
            logicalExpr.operator match {
              case AND =>
                acceptExpressionInner(logicalExpr.left, context.copy(kind = FalseJump, falseJumpLabel = newFalseLabel(afterLabel)))
                acceptExpressionInner(logicalExpr.right, context)
                afterLabel()
              case NAND => visitFactor(Factor(logicalExpr.position, logicalExpr.copy(operator = AND), Factor.Operator.NOT, None, logicalExpr.dataType), context)
              case OR =>
                acceptExpressionInner(logicalExpr.left, context.copy(kind = TrueJump, trueJumpLabel = newTrueLabel(afterLabel)))
                acceptExpressionInner(logicalExpr.right, context)
                afterLabel()
              case NOR => visitFactor(Factor(logicalExpr.position, logicalExpr.copy(operator = OR), Factor.Operator.NOT, None, logicalExpr.dataType), context)
              case XOR =>
                acceptExprCreateBoolValue(logicalExpr.left)
                acceptExprCreateBoolValue(logicalExpr.right)
                IXOR()
                if (lastXORStatement) {
                  context.kind match {
                    case TrueJump => IFNE(context.trueJumpLabel)
                    case FalseJump => IFEQ(context.falseJumpLabel)
                  }
                }
              case XNOR =>
                acceptExprCreateBoolValue(logicalExpr.left)
                acceptExprCreateBoolValue(logicalExpr.right)
                IXOR()
                if (lastXORStatement) {
                  context.kind match {
                    case TrueJump => IFEQ(context.trueJumpLabel)
                    case FalseJump => IFNE(context.falseJumpLabel)
                  }
                }
            }
        }
      }

      def visitRelation(relation: Relation, context: ExpressionContext) {
        import Relation.Operator._
        import mv._

        val (jumpLabel, jumpInverted) = context.kind match {
          case ExpressionContext.JumpKind.TrueJump => (context.trueJumpLabel, false)
          case ExpressionContext.JumpKind.FalseJump => (context.falseJumpLabel, true)
        }
        relation.right match {
          case NoExpression =>
            acceptExpressionInner(relation.left, context)
            relation.operator match {
              case EQ => if (jumpInverted) IFNE(jumpLabel) else IFEQ(jumpLabel)
              case NEQ => if (jumpInverted) IFEQ(jumpLabel) else IFNE(jumpLabel)
            }
          case _ =>
            if (relation.left.dataType == NullType || relation.right.dataType == NullType) {
              if (relation.left.dataType == NullType) acceptExpressionInner(relation.right, context)
              else acceptExpressionInner(relation.left, context) //also handles the strange corner case where both expression are null literals, e.g. if (null=null) then ... or if (null/=null) then
              relation.operator match {
                case EQ => if (jumpInverted) IFNONNULL(jumpLabel) else IFNULL(jumpLabel)
                case NEQ => if (jumpInverted) IFNULL(jumpLabel) else IFNONNULL(jumpLabel)
              }
            } else {
              acceptExpressionInner(relation.left, context)
              acceptExpressionInner(relation.right, context)
              (relation.left.dataType: @unchecked) match {
                case arrayType: ArrayType =>
                  relation.operator match {
                    case EQ | NEQ =>
                      if (relation.left.dataType == SymbolTable.stringType) INVOKEVIRTUAL("java/lang/String", "equals", "(Ljava/lang/Object;)Z")
                      else if (arrayType.dimensions.size == 1) INVOKESTATIC("java/util/Arrays", "equals", "(" + (getJVMDataType(relation.left.dataType) * 2) + ")Z")
                      else INVOKESTATIC("java/util/Arrays", "deepEquals", "([Ljava/lang/Object;[Ljava/lang/Object;)Z")

                      if (relation.operator == EQ) if (jumpInverted) IFEQ(jumpLabel) else IFNE(jumpLabel)
                      else if (jumpInverted) IFNE(jumpLabel) else IFEQ(jumpLabel)
                    case LT | LEQ =>
                      INVOKESTATIC(RUNTIME, relation.operator.toString, "(" + (getJVMDataType(relation.left.dataType) * 2) + ")Z")
                      if (jumpInverted) IFEQ(jumpLabel) else IFNE(jumpLabel)
                    case GT | GEQ =>
                      //The relations > (greater than) and >= (greater than or equal) are defined to be the complements of the <= and < operators,
                      //respectively, for the same two operands.
                      val operatorName = if (relation.operator == GT) "LEQ" else "LT"
                      INVOKESTATIC(RUNTIME, operatorName, "(" + (getJVMDataType(relation.left.dataType) * 2) + ")Z")
                      if (jumpInverted) IFNE(jumpLabel) else IFEQ(jumpLabel)
                  }
                case recordType: RecordType =>
                  INVOKEVIRTUAL(recordType.implementationName, "equals", "(Ljava/lang/Object;)Z")
                  relation.operator match {
                    case EQ => if (jumpInverted) IFEQ(jumpLabel) else IFNE(jumpLabel)
                    case NEQ => if (jumpInverted) IFNE(jumpLabel) else IFEQ(jumpLabel)
                  }
                case _: AccessType =>
                  relation.operator match {
                    case EQ => if (jumpInverted) IF_ACMPNE(jumpLabel) else IF_ACMPEQ(jumpLabel)
                    case NEQ => if (jumpInverted) IF_ACMPEQ(jumpLabel) else IF_ACMPNE(jumpLabel)
                  }
                case _: IntegerType | _: EnumerationType =>
                  relation.operator match {
                    case EQ => if (jumpInverted) IF_ICMPNE(jumpLabel) else IF_ICMPEQ(jumpLabel)
                    case NEQ => if (jumpInverted) IF_ICMPEQ(jumpLabel) else IF_ICMPNE(jumpLabel)
                    case LT => if (jumpInverted) IF_ICMPGE(jumpLabel) else IF_ICMPLT(jumpLabel)
                    case LEQ => if (jumpInverted) IF_ICMPGT(jumpLabel) else IF_ICMPLE(jumpLabel)
                    case GT => if (jumpInverted) IF_ICMPLE(jumpLabel) else IF_ICMPGT(jumpLabel)
                    case GEQ => if (jumpInverted) IF_ICMPLT(jumpLabel) else IF_ICMPGE(jumpLabel)
                  }
                case _: RealType =>
                  relation.operator match {
                    case EQ => DCMPL; if (jumpInverted) IFNE(jumpLabel) else IFEQ(jumpLabel)
                    case NEQ => DCMPL; if (jumpInverted) IFEQ(jumpLabel) else IFNE(jumpLabel)
                    case LT => DCMPG; if (jumpInverted) IFGE(jumpLabel) else IFLT(jumpLabel)
                    case LEQ => DCMPG; if (jumpInverted) IFGT(jumpLabel) else IFLE(jumpLabel)
                    case GT => DCMPL; if (jumpInverted) IFLE(jumpLabel) else IFGT(jumpLabel)
                    case GEQ => DCMPL; if (jumpInverted) IFLT(jumpLabel) else IFGE(jumpLabel)
                  }
                case _: PhysicalType =>
                  LCMP()
                  relation.operator match {
                    case EQ => if (jumpInverted) IFNE(jumpLabel) else IFEQ(jumpLabel)
                    case NEQ => if (jumpInverted) IFEQ(jumpLabel) else IFNE(jumpLabel)
                    case LT => if (jumpInverted) IFGE(jumpLabel) else IFLT(jumpLabel)
                    case LEQ => if (jumpInverted) IFGT(jumpLabel) else IFLE(jumpLabel)
                    case GT => if (jumpInverted) IFLE(jumpLabel) else IFGT(jumpLabel)
                    case GEQ => if (jumpInverted) IFLT(jumpLabel) else IFGE(jumpLabel)
                  }
              }
            }
        }
      }

      def visitSimpleExpression(simpleExpr: SimpleExpression) {
        import SimpleExpression._
        import mv._

        acceptExpressionInner(simpleExpr.left)
        acceptExpressionInnerOption(simpleExpr.rightOption)
        for (addOperator <- simpleExpr.addOperator) {
          addOperator match {
            case AddOperator.PLUS =>
              (simpleExpr.dataType: @unchecked) match {
                case _: IntegerType => IADD
                case _: RealType => DADD
                case _: PhysicalType => LADD
              }
            case AddOperator.MINUS =>
              (simpleExpr.dataType: @unchecked) match {
                case _: IntegerType => ISUB
                case _: RealType => DSUB
                case _: PhysicalType => LSUB
              }
            case AddOperator.CONCATENATION => INVOKESTATIC(RUNTIME, "concatenate", "(" + getJVMDataType(simpleExpr.left.dataType) + getJVMDataType(simpleExpr.rightOption.get.dataType) + ")" + getJVMDataType(simpleExpr.dataType))
          }
        }
        for (signOperator <- simpleExpr.signOperator) {
          signOperator match {
            case SignOperator.PLUS => // nothing
            case SignOperator.MINUS =>
              (simpleExpr.dataType: @unchecked) match {
                case _: IntegerType => INEG
                case _: RealType => DNEG
                case _: PhysicalType => LNEG
              }
          }
        }
      }

      def visitTerm(term: Term) {
        import Term.Operator._
        import mv._

        def loadOperands() {
          acceptExpressionInner(term.left)
          acceptExpressionInner(term.right)
        }
        ((term.left.dataType, term.right.dataType): @unchecked) match {
          case (_: IntegerType, _: IntegerType) =>
            loadOperands()
            term.operator match {
              case MUL => IMUL
              case DIV => IDIV
              case MOD => INVOKESTATIC(RUNTIME, "mod", "(II)I")
              case REM => IREM
            }
          case (_: RealType, _: RealType) =>
            loadOperands()
            (term.operator: @unchecked) match {
              case MUL => DMUL
              case DIV => DDIV
            }
          case (_: PhysicalType, _: IntegerType) =>
            loadOperands()
            I2L
            (term.operator: @unchecked) match {
              case MUL => LMUL
              case DIV => LDIV
            }
          case (_: PhysicalType, _: RealType) =>
            acceptExpressionInner(term.left)
            L2D
            acceptExpressionInner(term.right)
            (term.operator: @unchecked) match {
              case MUL => DMUL
              case DIV => DDIV
            }
            D2L
          case (_: IntegerType, _: PhysicalType) =>
            acceptExpressionInner(term.left)
            I2L
            acceptExpressionInner(term.right)
            LMUL
          case (_: RealType, _: PhysicalType) =>
            loadOperands()
            L2D
            DMUL
            D2L
          case (_: PhysicalType, _: PhysicalType) =>
            loadOperands()
            LDIV
            L2I
          case (_: RealType, _: IntegerType) =>
            loadOperands()
            I2D
            (term.operator: @unchecked) match {
              case MUL => DMUL
              case DIV => DDIV
            }
          case (_: IntegerType, _: RealType) =>
            acceptExpressionInner(term.left)
            I2D
            acceptExpressionInner(term.right)
            DMUL
        }
      }

      def visitTypeCastExpression(typeCastExpr: TypeCastExpression) {
        import mv._

        acceptExpressionInner(typeCastExpr.expression)
        (typeCastExpr.dataType, typeCastExpr.expression.dataType) match {
          case (_: IntegerType, _: RealType) => D2I
          case (_: IntegerType, _: PhysicalType) => L2I
          case (_: RealType, _: IntegerType) => I2D
          case (_: RealType, _: PhysicalType) => L2D
          case (_: PhysicalType, _: IntegerType) => I2L
          case (_: PhysicalType, _: RealType) => D2L
          case _ => error("not implemented")
        }
      }
    }

    def visitAssertionStatement(assertStmt: AssertionStatement, context: Context) {
      import context._
      import mv._

      createDebugLineNumberInformation(assertStmt)

      val trueJumpLabel = createLabel
      val falseJumpLabel = createLabel

      def generateAssertCode() {
        falseJumpLabel()
        LDC(context.designUnit)
        acceptExpressionOption(assertStmt.reportExpression)
        acceptExpressionOption(assertStmt.severityExpression, None, false)
        val desc = "Ljava/lang/String;" +
          (if (assertStmt.reportExpression.isDefined) "Ljava/lang/String;" else "") +
          (if (assertStmt.severityExpression.isDefined) "I" else "")
        INVOKESTATIC(RUNTIME, "assertVHDL", "(" + desc + ")V")
        trueJumpLabel()
      }

      assertStmt.condition match {
        //do not generate condition code for assert statements like assert false ..., assert true ...
        case Literal(_, _, _, dataType, value) if ((value == 0 || value == 1) && dataType == SymbolTable.booleanType) =>
          if (value == 1) generateAssertCode() //only generate code for assert true ... because assert false can never be true, so the assert statement is dead code
        case _ =>
          acceptExpression(assertStmt.condition, Some(new ExpressionContext(trueJumpLabel = trueJumpLabel, falseJumpLabel = falseJumpLabel, kind = ExpressionContext.JumpKind.TrueJump)))
          generateAssertCode()
      }
    }

    def acceptGenerateStatements(nodes: Seq[ASTNode], context: Context) {
      nodes.collect(_ match {
        case x: GenerateStatement => x
      }).foreach(acceptGenerateStatement(_, context))
    }

    def acceptGenerateStatement(node: GenerateStatement, context: Context) {
      import context._
      import mv._
      node match {
        case ifGenerateStmt: IfGenerateStatement =>
          val endLabel = createLabel
          context.cw.visitField(Opcodes.ACC_PUBLIC, ifGenerateStmt.label.get.text, "Ljava/lang/Object;").visitAnnotation(ci(classOf[BlockAnnotation]), true).visitEnd()
          ifGenerateStmt.ifThenList.map {
            part =>
              val falseJumpLabel = createLabel
              val trueJumpLabel = createLabel
              acceptExpression(part.condition, Some(new ExpressionContext(trueJumpLabel = trueJumpLabel, falseJumpLabel = falseJumpLabel, kind = ExpressionContext.JumpKind.FalseJump)))
              trueJumpLabel()
              val blockCW = visitBlockStatement(BlockStatement(part.condition.position, part.label, None, None, None, None, None, part.declarativeItems, part.concurrentStatements, None), context)
              NEW(blockCW.className)
              DUP
              ALOAD(0)
              INVOKESPECIAL(blockCW.className, "<init>", "(Ljava/lang/Object;)V")
              PUTSTATIC(context.cw.className, ifGenerateStmt.label.get.text, "Ljava/lang/Object;")
              GOTO(endLabel)
              falseJumpLabel()
          }
          ifGenerateStmt.elsePart.foreach {
            part =>
              part match {
                case IfGenerateStatement.IfThenPart(None, NoExpression, Seq(), Seq(), None) =>
                  //this comes from a case generate statement that does not contain a others choice
                  context.mv.throwNewException(p(classOf[VHDLRuntimeException]), "case generate fall through")
                case _ =>
                  val blockCW = visitBlockStatement(BlockStatement(NoPosition, part.label.orElse(Some(Identifier("else" + ifGenerateStmt.label.get.text))), None, None, None, None, None, part.declarativeItems, part.concurrentStatements, None), context)
                  NEW(blockCW.className)
                  DUP
                  ALOAD(0)
                  INVOKESPECIAL(blockCW.className, "<init>", "(Ljava/lang/Object;)V")
                  PUTSTATIC(context.cw.className, ifGenerateStmt.label.get.text, "Ljava/lang/Object;")
              }
          }
          endLabel()
        case forGenerateStmt: ForGenerateStatement =>
          context.cw.visitField(Opcodes.ACC_PUBLIC, forGenerateStmt.label.get.text, "[Ljava/lang/Object;").visitAnnotation(ci(classOf[BlockAnnotation]), true).visitEnd()
          val blockCW = visitBlockStatement(BlockStatement(forGenerateStmt.position, forGenerateStmt.label, None, None, None, None, None, forGenerateStmt.declarativeItems, forGenerateStmt.concurrentStatements, None), context)
          loadDiscreteRange(forGenerateStmt.discreteRange)
          INVOKEVIRTUAL("scala/collection/immutable/Range$Inclusive", "length", "()I")
          ISUB
          ANEWARRAY("java/lang/Object")
          PUTSTATIC(cw.className, forGenerateStmt.label.get.text, "[Ljava/lang/Object;")
          genericForStatement(forGenerateStmt.discreteRange, forGenerateStmt.symbol, forGenerateStmt, context) {
            (_, _) =>
              GETSTATIC(cw.className, forGenerateStmt.label.get.text, "[Ljava/lang/Object;")
              ALOAD(0)
              GETFIELD(cw.className, forGenerateStmt.symbol.name, "I")
              NEW(blockCW.className)
              DUP
              ALOAD(0)
              ALOAD(0)
              GETFIELD(cw.className, forGenerateStmt.symbol.name, "I")
              INVOKESPECIAL(blockCW.className, "<init>", "(Ljava/lang/Object;I)V")
              AASTORE
          }
      }
    }

    def visitIfStatement(ifStmt: IfStatement, context: Context) {
      import context._
      import mv._

      createDebugLineNumberInformation(ifStmt)
      val endLabel = createLabel

      def generateCodeForIfThenPart(part: IfStatement.IfThenPart, generateGOTO: Boolean) {
        val falseJumpLabel = createLabel
        val trueJumpLabel = createLabel
        acceptExpression(part.condition, Some(new ExpressionContext(trueJumpLabel = trueJumpLabel, falseJumpLabel = falseJumpLabel, kind = ExpressionContext.JumpKind.FalseJump)))
        trueJumpLabel()
        acceptNodes(part.sequentialStatements, context)
        if (generateGOTO && !part.sequentialStatements.exists(_.isInstanceOf[ReturnStatement])) GOTO(endLabel)
        falseJumpLabel()
      }

      val elseIfList = ifStmt.ifThenList.tail

      generateCodeForIfThenPart(ifStmt.ifThenList.head, elseIfList.nonEmpty || ifStmt.elseSequentialStatements.isDefined)
      if (elseIfList.nonEmpty) {
        elseIfList.foreach(generateCodeForIfThenPart(_, true))
        generateCodeForIfThenPart(elseIfList.last, ifStmt.elseSequentialStatements.isDefined)
      }
      ifStmt.elseSequentialStatements.foreach(acceptNodes(_, context))

      endLabel()
    }

    def visitWaitStatement(waitStmt: WaitStatement, context: Context) {
      // TODO use continuations
      //import context._

      //mv.createDebugLineNumberInformation(waitStmt)
      //error("not implemented")
    }

    /**
     * Creates an conditional jump to a specific label
     *
     * if condition is None this will allways jump, else
     * it will generarte code that is a if statement and a jump
     * {{{ if (condition) GOTO(target) }}}
     *
     * @param targetLabel the target of the jump
     */
    def createConditionalJump(stmt: SequentialStatement, condition: Option[Expression], targetLabel: RichLabel, context: Context) {
      import context._
      import mv._

      val trueJumpLabel = createLabel
      val falseJumpLabel = createLabel
      createDebugLineNumberInformation(stmt)
      acceptExpressionOption(condition, Some(new ExpressionContext(trueJumpLabel = trueJumpLabel, falseJumpLabel = falseJumpLabel, kind = ExpressionContext.JumpKind.FalseJump)))
      trueJumpLabel()
      GOTO(targetLabel)
      falseJumpLabel()
    }

    def visitNextStatement(nextStmt: NextStatement, context: Context) {
      createConditionalJump(nextStmt, nextStmt.condition, context.loopLabels(nextStmt.loopStatement).continueLabel, context)
    }

    def visitExitStatement(exitStmt: ExitStatement, context: Context) {
      createConditionalJump(exitStmt, exitStmt.condition, context.loopLabels(exitStmt.loopStatement).breakLabel, context)
    }

    def loadDiscreteRange(discreteRange: DiscreteRange)(implicit mv: RichMethodVisitor) =
      discreteRange.rangeOrSubTypeIndication match {
        case Left(range) =>
          range.expressionsOrName match {
            case Right(attributeName) => acceptExpression(attributeName)
            case Left((from, direction, to)) =>
              mv.NEW(getJVMName(discreteRange.dataType))
              mv.DUP
              acceptExpression(from)
              acceptExpression(to)
              if (direction == Range.Direction.To) mv.ICONST_1
              else mv.ICONST_M1
              mv.INVOKESPECIAL("scala/collection/immutable/Range$Inclusive", "<init>", "(III)V")
          }
        case Right(subTypeIndication) =>
          import mv._
          val scalarType = subTypeIndication.dataType.asInstanceOf[ScalarType]
          NEW(getJVMName(discreteRange.dataType))
          DUP
          pushAnyVal(scalarType.left)
          pushAnyVal(scalarType.right)
          if (scalarType.isAscending) ICONST_1 else ICONST_M1
          INVOKESPECIAL("scala/collection/immutable/Range$Inclusive", "<init>", "(III)V")
      }

    /*
    * generates a generic for in the form:
    * scala.Range.Inclusive $range
    * int i
    * for($range=loadDiscreteRange(discreteRange),i=$range.start;i!=$range.end;i++){
    *   body
    * }
    */
    def genericForStatement(discreteRange: DiscreteRange, symbol: ConstantSymbol, stmt: ASTNode, context: Context)(body: (RichLabel, RichLabel) => Unit) {
      import context._
      import mv._

      val varIndex = symbol.index
      val continueLabel = createLabel
      val breakLabel = createLabel
      val conditionTestLabel = createLabel
      val startLabel = createLabel

      startLabel()
      createDebugLineNumberInformation(stmt)
      loadDiscreteRange(discreteRange)
      ASTORE(varIndex - 1)
      ALOAD(varIndex - 1)
      (symbol.owner: @unchecked) match {
        case _: SubprogramSymbol =>
          INVOKEVIRTUAL(p(classOf[scala.Range.Inclusive]), "start", "()I")
          ISTORE(varIndex)
        case _: ProcessSymbol | _: BlockSymbol =>
          cw.visitField(Opcodes.ACC_PRIVATE, symbol.name, "I")
          ALOAD(0)
          INVOKEVIRTUAL(p(classOf[scala.Range.Inclusive]), "start", "()I")
          PUTFIELD(cw.className, symbol.name, "I")
      }

      GOTO(conditionTestLabel)
      continueLabel()

      body(continueLabel, breakLabel)

      (symbol.owner: @unchecked) match {
        case _: SubprogramSymbol =>
          ILOAD(varIndex)
          ALOAD(varIndex - 1)
          INVOKEVIRTUAL(p(classOf[scala.Range.Inclusive]), "step", "()I")
          IADD
          ISTORE(varIndex)

          conditionTestLabel()
          ILOAD(varIndex)
        case _: ProcessSymbol | _: BlockSymbol =>
          ALOAD(0)
          DUP
          GETFIELD(cw.className, symbol.name, "I")
          ALOAD(varIndex - 1)
          INVOKEVIRTUAL(p(classOf[scala.Range.Inclusive]), "step", "()I")
          IADD
          PUTFIELD(cw.className, symbol.name, "I")
          conditionTestLabel()

          ALOAD(0)
          GETFIELD(cw.className, symbol.name, "I")
      }
      ALOAD(varIndex - 1)
      INVOKEVIRTUAL(p(classOf[scala.Range.Inclusive]), "end", "()I")
      IF_ICMPNE(continueLabel)
      breakLabel()
      if (symbol.owner.isInstanceOf[SubprogramSymbol]) {
        visitLocalVariable(symbol.name, "I", null, startLabel, breakLabel, varIndex)
        visitLocalVariable("$range", ci(classOf[scala.Range.Inclusive]), null, startLabel, breakLabel, varIndex - 1)
      }
    }

    def visitForStatement(forStmt: ForStatement, context: Context) {
      genericForStatement(forStmt.discreteRange, forStmt.symbol, forStmt, context) {
        (continueLabel, breakLabel) => acceptNodes(forStmt.sequentialStatements, context.insertLoopLabels(forStmt.position, new LoopLabels(continueLabel, breakLabel)))
      }
    }

    def visitLoopStatement(loopStmt: LoopStatement, context: Context) {
      import context.mv._
      val continueLabel = createLabel
      val breakLabel = createLabel

      createDebugLineNumberInformation(loopStmt)
      continueLabel()
      acceptNodes(loopStmt.sequentialStatements, context.insertLoopLabels(loopStmt.position, new LoopLabels(continueLabel, breakLabel)))
      GOTO(continueLabel)
      breakLabel()
    }

    def createDefaultValuesMethods(interfaceListOption: Option[Seq[InterfaceList.AbstractInterfaceElement]], parentName: String, cw: RichClassWriter) {
      for (interfaceList <- interfaceListOption) {
        for (element <- interfaceList) {
          element match {
            case objectDeclaration: InterfaceList.InterfaceObjectDeclaration =>
              for (expression <- objectDeclaration.expression) {
                for (identifier <- objectDeclaration.identifiers) {
                  val mv = cw.createMethod(Opcodes.ACC_STATIC, "$default$" + parentName + "_" + identifier.text, returnType = getJVMDataType(expression.dataType))
                  visitReturnStatement(ReturnStatement(NoPosition, None, objectDeclaration.expression), Context(cw, mv))
                  mv.endMethod()
                }
              }
          }
        }
      }
    }

    def acceptDeclarativeItems(declarativeItems: Seq[ASTNode], flags: Int, context: Context) {
      val (objectDeclarations, rest) = declarativeItems.partition(_.isInstanceOf[ObjectDeclaration])
      objectDeclarations.foreach {
        objectDeclaration =>
          objectDeclaration.asInstanceOf[ObjectDeclaration].symbols.foreach {
            symbol =>
              symbol match {
                case constantSymbol: ConstantSymbol => if (!(constantSymbol.isDeferred && constantSymbol.isDefined)) context.cw.visitField(Opcodes.ACC_PUBLIC + flags, symbol.name, getJVMDataType(symbol))
                case _ => context.cw.visitField(Opcodes.ACC_PUBLIC + flags, symbol.name, getJVMDataType(symbol))
              }
          }
          acceptNode(objectDeclaration, context)
      }
      acceptNodes(rest, context)
    }

    def visitComponentInstantiationStatement(componentInstantiationStmt: ComponentInstantiationStatement) = error("not implemented")

    def visitComponentDeclaration(componentDeclaration: ComponentDeclaration, context: Context) {
      val ports = componentDeclaration.symbol.ports
      val generics = componentDeclaration.symbol.generics
      val name = componentDeclaration.symbol.name
      val cw = createInnerClass(context.cw, context.cw.className + "$" + name, name, classOf[ComponentAnnotation], createEmptyConstructor = true)
      createDefaultValuesMethods(componentDeclaration.genericInterfaceList, name, cw)
      createDefaultValuesMethods(componentDeclaration.portInterfaceList, name, cw)

      cw.createMethod(flags = Opcodes.ACC_ABSTRACT, name = "instantiate", parameters = getJVMParameterList(generics) + getJVMParameterList(ports), returnType = "V")
      cw.writeToFile()
    }

    def visitAliasDeclaration(aliasDeclaration: AliasDeclaration, context: Context) {
      for (subType <- aliasDeclaration.subType; constraint <- subType.constraint) {
        constraint match {
          case Right(discreteRanges) =>
            import context._
            import mv._
            discreteRanges.foreach(loadDiscreteRange)
            acceptExpression(aliasDeclaration.name)
            val arrayType = subType.dataType.asInstanceOf[ArrayType]
            INVOKESTATIC(RUNTIME, "createRuntimeArray$" + getScalaSpecializedMethodSuffix(arrayType.elementType),
              "(" + (ci(classOf[scala.Range.Inclusive]) * arrayType.dimensions.size) + getJVMDataType(arrayType) + ")" + getJVMDataType(arrayType))
            ASTORE(aliasDeclaration.symbol.index)
          case _ => error("not possible")
        }
      }
    }

    def createClinitAndAcceptItems(designUnit: String, declarativeItems: Seq[ASTNode], cw: RichClassWriter) {
      val mv = cw.createMethod(flags = Opcodes.ACC_STATIC + Opcodes.ACC_FINAL, name = "<clinit>", parameters = "", returnType = "V")
      acceptDeclarativeItems(declarativeItems, Opcodes.ACC_STATIC + Opcodes.ACC_FINAL, Context(cw, mv, Map(), designUnit))
      mv.RETURN
      mv.endMethod()
    }

    def visitEntityDeclaration(entityDeclaration: EntityDeclaration) {
      val cw = createClass(Opcodes.ACC_ABSTRACT, entityDeclaration.symbol.implementationName, "java/lang/Object", classOf[EntityAnnotation], createEmptyConstructor = true)
      createDefaultValuesMethods(entityDeclaration.genericInterfaceList, entityDeclaration.symbol.name, cw)
      createDefaultValuesMethods(entityDeclaration.portInterfaceList, entityDeclaration.symbol.name, cw)
      createClinitAndAcceptItems(entityDeclaration.identifier.text, entityDeclaration.declarativeItems, cw)
      acceptNodes(entityDeclaration.concurrentStatements, Context(cw = cw, designUnit = entityDeclaration.identifier.text))
      cw.writeToFile()
    }

    def visitConfigurationDeclaration(configurationDeclaration: ConfigurationDeclaration) {
      val cw = createClass(Opcodes.ACC_FINAL, configurationDeclaration.symbol.implementationName, "java/lang/Object", classOf[ConfigurationAnnotation])
      createClinitAndAcceptItems(configurationDeclaration.identifier.text, configurationDeclaration.declarativeItems, cw)
      cw.writeToFile()
    }

    def visitPackageDeclaration(packageDeclaration: PackageDeclaration) {
      val cw = createClass(Opcodes.ACC_ABSTRACT, packageDeclaration.symbol.implementationName, "java/lang/Object", classOf[PackageHeaderAnnotation])
      createClinitAndAcceptItems(packageDeclaration.identifier.text, packageDeclaration.declarativeItems, cw)
      cw.writeToFile()
    }

    def visitPackageBodyDeclaration(packageBodyDeclaration: PackageBodyDeclaration) {
      val cw = createClass(Opcodes.ACC_FINAL, packageBodyDeclaration.symbol.implementationName, packageBodyDeclaration.symbol.copy(isBody = false).implementationName, classOf[PackageBodyAnnotation])
      createClinitAndAcceptItems(packageBodyDeclaration.identifier.text, packageBodyDeclaration.declarativeItems, cw)
      cw.writeToFile()
    }

    def visitArchitectureDeclaration(architectureDeclaration: ArchitectureDeclaration) {
      val cw = createClass(Opcodes.ACC_FINAL, architectureDeclaration.symbol.implementationName, architectureDeclaration.symbol.entity.implementationName, classOf[ArchitectureAnnotation], createEmptyConstructor = false)
      val ports = architectureDeclaration.symbol.entity.ports
      val generics = architectureDeclaration.symbol.entity.generics
      val combinedList = generics ++ ports
      combinedList.foreach(s => cw.visitField(Opcodes.ACC_PUBLIC, s.name, getJVMDataType(s)))

      val processSymbols = architectureDeclaration.concurrentStatements.collect(_ match {
        case processStatement: ProcessStatement => processStatement.symbol
      })

      for (symbol <- processSymbols) {
        cw.visitField(Opcodes.ACC_PUBLIC, symbol.name, "L" + cw.className + "$" + symbol.name + ";").
          visitAnnotation(if (symbol.isPostponed) ci(classOf[PostponedProcessAnnotation]) else ci(classOf[ProcessAnnotation]), true).visitEnd()
      }
      {
        val mv = cw.createMethod(name = "<init>", parameters = getJVMParameterList(generics) + getJVMParameterList(ports), returnType = "V")
        import mv._

        ALOAD(0)
        INVOKESPECIAL("java/lang/Object", "<init>", "()V")
        for ((symbol, i) <- combinedList zipWithIndex) {
          ALOAD(0)
          loadInstruction(symbol.dataType, i + 1)
          PUTFIELD(cw.className, symbol.name, getJVMDataType(symbol))
        }
        for (symbol <- processSymbols) {
          ALOAD(0)
          NEW(cw.className + "$" + symbol.name)
          DUP
          ALOAD(0)
          INVOKESPECIAL(cw.className + "$" + symbol.name, "<init>", "(L" + cw.className + ";)V")
          PUTFIELD(cw.className, symbol.name, "L" + cw.className + "$" + symbol.name + ";")
        }
        val context = Context(cw, mv, Map(), architectureDeclaration.identifier.text)
        acceptDeclarativeItems(architectureDeclaration.declarativeItems, Opcodes.ACC_FINAL, context)
        acceptGenerateStatements(architectureDeclaration.concurrentStatements, Context(cw, mv, Map(), architectureDeclaration.identifier.text))
        RETURN
        endMethod()
      }
      acceptNodes(architectureDeclaration.concurrentStatements, Context(cw, null, Map(), architectureDeclaration.identifier.text))
      cw.writeToFile()
    }

    def visitReportStatement(reportStmt: ReportStatement, context: Context) {
      import context._
      import mv._

      createDebugLineNumberInformation(reportStmt)
      LDC(context.designUnit)
      acceptExpression(reportStmt.reportExpression)
      acceptExpressionOption(reportStmt.severityExpression)
      val desc = "Ljava/lang/String;Ljava/lang/String;" + (if (reportStmt.severityExpression.isDefined) "I" else "")
      INVOKESTATIC(RUNTIME, "report", "(" + desc + ")V")
    }

    def visitReturnStatement(returnStmt: ReturnStatement, context: Context) {
      import context._
      import mv._

      createDebugLineNumberInformation(returnStmt)
      //An implicit call to FILE_CLOSE exists in a subprogram body for every file object declared in the corresponding subprogram declarative part.
      //Each such call associates a unique file object with the formal parameter F and is called whenever the corresponding subprogram completes its execution.
      //close all open files in a subprogram before we return from it
      for (symbol <- context.fileSymbols) {
        ALOAD(symbol.index)
        INVOKESTATIC(RUNTIME, "file_close", "(" + ci(classOf[RuntimeFile]) + ")V")
      }
      returnStmt.expression match {
        case None =>
          val procedureSymbol = returnStmt.procedureSymbol
          //returns the copyBack Symbols
          procedureSymbol.copyBackSymbols match {
            case Seq() => RETURN
            case Seq(symbol) =>
              //we have only one symbol
              loadSymbol(symbol)
              symbol.dataType.asInstanceOf[ScalarType] match {
                case _: IntegerType | _: EnumerationType => IRETURN
                case _: RealType => DRETURN
                case _: PhysicalType => LRETURN
              }
            case _ =>
              //we need to return more than one symbol, so we create a scala TupleX
              NEW("scala/Tuple" + procedureSymbol.copyBackSymbols.size)
              DUP
              for (symbol <- procedureSymbol.copyBackSymbols) {
                loadSymbol(symbol)
                doBox(symbol.dataType.asInstanceOf[ScalarType])
              }
              INVOKESPECIAL("scala/Tuple" + procedureSymbol.copyBackSymbols.size, "<init>", "(" + (("Ljava/lang/Object;") * procedureSymbol.copyBackSymbols.size) + ")V")
              ARETURN
          }
        case Some(expr) =>
          acceptExpression(expr)
          expr.dataType match {
            case _: IntegerType | _: EnumerationType => IRETURN
            case _: RealType => DRETURN
            case _: PhysicalType => LRETURN
            case _ => ARETURN
          }
      }
    }

    def loadTarget(expression: Expression)(implicit mv: RichMethodVisitor): (RuntimeSymbol, DataType) = {
      implicit val implicitMV = mv
      import mv._

      (expression: @unchecked) match {
        case ItemExpression(_, symbol) => (symbol, symbol.dataType)
        case ArrayAccessExpression(symbol, _, dataType, None) => (symbol, dataType)
        case ArrayAccessExpression(symbol, indexes, elementType, Some(expression)) =>
          loadSymbol(symbol)
          (symbol.dataType: @unchecked) match {
            case constraintArray: ConstrainedArrayType =>
              for (((expr, i), dim) <- indexes.zipWithIndex.zip(constraintArray.dimensions)) {
                acceptExpression(expr)
                if (dim.from != 0) {
                  pushInt(dim.from)
                  pushInt(dim.to)
                  INVOKESTATIC(RUNTIME, "getArrayIndex1D", "(III)I")
                }
                indexes.size - 1 - i match {
                  case 0 => arrayLoadInstruction(constraintArray.elementType)
                  case _ => AALOAD()
                }
              }
            case unconstrainedArrayType: UnconstrainedArrayType =>
              indexes.foreach(acceptExpression(_))
              unconstrainedArrayType.elementType match {
                case _: RecordType =>
                  INVOKEVIRTUAL(getJVMName(symbol), "getValue", "(" + ("I" * indexes.size) + ")" + "Ljava/lang/Object;")
                  CHECKCAST(getJVMName(unconstrainedArrayType.elementType))
                case _ => INVOKEVIRTUAL(getJVMName(symbol), "getValue", "(" + ("I" * indexes.size) + ")" + getJVMDataType(unconstrainedArrayType.elementType))
              }
          }
          loadTarget(expression)
        case FieldAccessExpression(owner, field, fieldDataType, expressionOption) =>
          if (!owner.owner.isInstanceOf[RuntimeSymbol]) loadSymbol(owner)
          expressionOption match {
            case None => (owner.makeCopy(field, owner.dataType), fieldDataType)
            case Some(expression) =>
              GETFIELD(owner.dataType.implementationName, field.text, getJVMDataType(fieldDataType))
              loadTarget(expression)
          }
      }
    }

    def checkIsInRange(dataType: DataType)(implicit mv: RichMethodVisitor) = dataType match {
      case scalarType: ScalarType =>
        if (scalarType.isSubType) {
          import mv._

          pushAnyVal(scalarType.lowerBound)
          pushAnyVal(scalarType.upperBound)
          scalarType match {
            case _: IntegerType | _: RealType | _: PhysicalType =>
              val typeString = getJVMDataType(scalarType)
              INVOKESTATIC(RUNTIME, "checkIsInRange", "(" + (typeString * 3) + ")" + typeString)
            case enumType: EnumerationType => INVOKESTATIC(enumType.baseType.get.implementationName, "checkIsInRange", "(III)I")
          }
        }
      //TODO add check for record and array types
      case _ =>
    }

    def visitVariableAssignmentStatement(varAssignStmt: VariableAssignmentStatement, context: Context) {
      import context._

      mv.createDebugLineNumberInformation(varAssignStmt)
      varAssignStmt match {
        case stmt: SimpleVariableAssignmentStatement =>
          stmt.target.nameOrAggregate match {
            case Left(name) =>
              val (target, targetType) = loadTarget(stmt.target.expression)
              target.owner match {
                case _: SubprogramSymbol | _: PackageSymbol | _: RuntimeSymbol =>
                case _ => mv.ALOAD(0)
              }
              acceptExpression(stmt.expression)
              checkIsInRange(targetType)
              mv.storeSymbol(target, targetType)
            case Right(aggregate) => error("not implemented")
          }
      }
    }

    def visitWhileStatement(whileStmt: WhileStatement, context: Context) {
      import context._
      import mv._

      val conditionTestLabel = createLabel
      val breakLabel = createLabel
      val continueLabel = createLabel

      createDebugLineNumberInformation(whileStmt)
      GOTO(conditionTestLabel)
      continueLabel()
      acceptNodes(whileStmt.sequentialStatements, context.insertLoopLabels(whileStmt.position, new LoopLabels(conditionTestLabel, breakLabel)))
      conditionTestLabel()
      acceptExpression(whileStmt.condition, Some(new ExpressionContext(trueJumpLabel = continueLabel, falseJumpLabel = breakLabel, kind = ExpressionContext.JumpKind.TrueJump)))
      breakLabel()
    }

    def visitFunctionDefinition(functionDefinition: FunctionDefinition, context: Context) {
      val functionSymbol = functionDefinition.symbol
      createDefaultValuesMethods(functionDefinition.parameterInterfaceList, functionSymbol.mangledName, context.cw)

      val flags = (if (functionSymbol.isStatic) Opcodes.ACC_STATIC else 0) + (if (functionSymbol.isSynchronized) Opcodes.ACC_SYNCHRONIZED else 0)
      val mv = context.cw.createMethod(flags = flags, name = functionSymbol.mangledName,
        parameters = getJVMParameterList(functionSymbol.parameters), returnType = getJVMDataType(functionSymbol.returnType))
      val newContext = Context(context.cw, mv, Map(), context.designUnit, functionDefinition.localSymbols.collect(_ match {
        case f: FileSymbol => f
      }))
      import mv._
      val startLabel = createLabel
      val stopLabel = createLabel

      startLabel()
      acceptNodes(functionDefinition.declarativeItems, newContext)
      acceptNodes(functionDefinition.sequentialStatements, newContext)
      stopLabel()
      createDebugLocalVariableInformation(functionDefinition.localSymbols, startLabel, stopLabel)
      endMethod()
    }

    def visitProcedureDefinition(procedureDefinition: ProcedureDefinition, context: Context) {
      val procedureSymbol = procedureDefinition.symbol
      createDefaultValuesMethods(procedureDefinition.parameterInterfaceList, procedureSymbol.mangledName, context.cw)

      val (returnType, signature) = procedureSymbol.copyBackSymbols match {
        case Seq() => ("V", null)
        case Seq(symbol) => (getJVMDataType(symbol), null)
        case _ =>
          ("Lscala/Tuple" + procedureSymbol.copyBackSymbols.size + ";",
            "()Lscala/Tuple" + procedureSymbol.copyBackSymbols.size + "<" + procedureSymbol.copyBackSymbols.map(symbol => getBoxedType(symbol.dataType)).mkString + ">;")
      }

      val flags = (if (procedureSymbol.isStatic) Opcodes.ACC_STATIC else 0) + (if (procedureSymbol.isSynchronized) Opcodes.ACC_SYNCHRONIZED else 0)
      val mv = context.cw.createMethod(flags = flags, name = procedureSymbol.mangledName, parameters = getJVMParameterList(procedureSymbol.parameters), returnType = returnType, signature = signature)
      val newContext = Context(context.cw, mv, Map(), context.designUnit, procedureDefinition.localSymbols.collect(_ match {
        case f: FileSymbol => f
      }))
      import mv._

      val startLabel = createLabel
      val stopLabel = createLabel
      startLabel()
      acceptNodes(procedureDefinition.declarativeItems, newContext)
      acceptNodes(procedureDefinition.sequentialStatements, newContext)
      visitReturnStatement(ReturnStatement(NoPosition, None, None, procedureSymbol), newContext)
      stopLabel()
      createDebugLocalVariableInformation(procedureDefinition.localSymbols, startLabel, stopLabel)
      endMethod()
    }

    def visitBlockStatement(blockStmt: BlockStatement, context: Context): RichClassWriter = {
      val name = blockStmt.label match {
        case None => "block" + blockStmt.position.line
        case Some(label) => label.text
      }
      require(blockStmt.guardExpression.isEmpty)
      //createGetSensitivityList(context, name, processStmt.symbol.sensitivityList)

      val cw = createInnerClass(context.cw, context.cw.className + "$" + name, name, classOf[BlockAnnotation], createEmptyConstructor = false)
      cw.visitField(Opcodes.ACC_PRIVATE + Opcodes.ACC_FINAL, "$owner", "L" + context.cw.className + ";");
      {
        val mv = cw.createMethod(name = "<init>", parameters = "L" + context.cw.className + ";")
        import mv._
        val startLabel = createLabel
        val endLabel = createLabel

        ALOAD(0)
        INVOKESPECIAL("java/lang/Object", "<init>", "()V")
        ALOAD(0)
        ALOAD(1)
        PUTFIELD(cw.className, "$owner", "L" + context.cw.className + ";")
        acceptDeclarativeItems(blockStmt.declarativeItems, 0, context.copy(cw = cw, mv = mv))
        acceptGenerateStatements(blockStmt.concurrentStatements, context.copy(cw = cw, mv = mv))
        RETURN
        endLabel()
        visitLocalVariable("this", "L" + cw.className + ";", null, startLabel, endLabel, 0)
        visitLocalVariable("owner", "L" + context.cw.className + ";", null, startLabel, endLabel, 1)
        endMethod()
      }
      acceptNodes(blockStmt.concurrentStatements, Context(cw = cw, mv = null, loopLabels = Map(), designUnit = context.designUnit))
      cw.writeToFile()
      cw
    }

    def visitCaseStatement(caseStmt: CaseStatement, context: Context) {
      import context._
      import mv._

      val endLabel = createLabel
      val defaultLabel = new Label()
      val labelList = caseStmt.alternatives.flatMap {
        alternative =>
          val label = new Label()
          alternative.choices.map(choice => if (choice.isOthers) defaultLabel else label)
      }

      createDebugLineNumberInformation(caseStmt)
      acceptExpression(caseStmt.expression)
      val keys = caseStmt.keys.sortBy(key => key)
      val firstKey = keys.head
      val lastKey = keys.last
      val labels = labelList.zip(caseStmt.keys).sortBy(x => x._2).unzip._1.toArray
      if (keys.distinct.size == (lastKey - firstKey + 1)) TABLESWITCH(firstKey, lastKey, defaultLabel, labels)
      else LOOKUPSWITCH(defaultLabel, keys.toArray, labels)

      for ((alternative, label) <- caseStmt.alternatives.zip(labelList.distinct)) {
        visitLabel(label)
        acceptNodes(alternative.sequentialStatements, context)
        if (!alternative.sequentialStatements.exists(_.isInstanceOf[ReturnStatement]) && (label ne defaultLabel)) GOTO(endLabel)
      }
      endLabel()
    }

    def visitProcedureCallStatement(procedureCallStmt: ProcedureCallStatement, context: Context) {
      import context._
      import mv._

      createDebugLineNumberInformation(procedureCallStmt)
      val procedureSymbol = procedureCallStmt.symbol
      procedureSymbol.attributes.get("foreign") match {
        case Some(attributeSymbol) if (attributeSymbol.isInstanceOf[ForeignAttributeSymbol]) =>
          loadParameters(procedureCallStmt.parameterAssociation)
          attributeSymbol.asInstanceOf[ForeignAttributeSymbol].jvmSignature match {
            case Left((className, methodName)) => INVOKESTATIC(className, methodName, "(" + getJVMParameterList(procedureSymbol.parameters) + ")V")
            case Right((className, methodName, parameterTypes)) => INVOKESTATIC(className, methodName, parameterTypes)
          }
        case _ =>
          val procedureCallType = if (procedureSymbol.isStatic) Opcodes.INVOKESTATIC
          else {
            ALOAD(0)
            Opcodes.INVOKEVIRTUAL
          }
          val returnType = if (procedureSymbol.needsCopyBack)
            (if (procedureSymbol.copyBackSymbols.size == 1) getJVMDataType(procedureSymbol.copyBackSymbols.head) else "scala/Tuple" + procedureSymbol.copyBackSymbols.size)
          else "V"

          procedureSymbol.owner match {
            case Runtime =>
              //implicitly declared procedures and functions
              val procedureName = procedureSymbol.name match {
                case "deallocate" =>
                  //converts a call to deallocate to a assignment with null => variable=null;
                  require(procedureCallStmt.parameterAssociation.get.parameters.size == 1)
                  val (target, targetType) = loadTarget(procedureCallStmt.parameterAssociation.get.parameters.head)
                  ACONST_NULL
                  storeSymbol(target, targetType)
                  None
                case "read" =>
                  //mangle read procedure name so that it matches one of the readX names in the runtime
                  Some("read" + getJVMDataType(procedureSymbol.parameters.head.dataType.asInstanceOf[FileType].elementType))
                case "file_open" =>
                  if (procedureSymbol.parameters.head.dataType.name == "status") Some("file_open_status")
                  else Some("file_open")
                case name => Some(name)
              }
              procedureName.foreach {
                loadParameters(procedureCallStmt.parameterAssociation)
                visitMethodInsn(procedureCallType, procedureSymbol.owner.implementationName, _, "(" + getJVMParameterList(procedureSymbol.parameters) + ")" + returnType)
              }
            case _ =>
              loadParameters(procedureCallStmt.parameterAssociation)
              visitMethodInsn(procedureCallType, procedureSymbol.owner.implementationName, procedureSymbol.mangledName, "(" + getJVMParameterList(procedureSymbol.parameters) + ")" + returnType)
          }
        /*
        //TODO copy back out values and call checkIsInRange
        //it is similarly an error if, after applying any conversion function or type conversion present in the formal part of the applicable association element, the value of the formal parameter does not
        //belong to the subtype denoted by the subtype indication of the actual.
        */
      }
    }

    def createGetSensitivityList(context: Context, name: String, sensitivityList: Seq[SignalSymbol]) {
      //creates code which is the same as : def getSensitivityListProcessName:Seq[Signal]=List(signal1,signal2)
      val mv = context.cw.visitMethod(Opcodes.ACC_PUBLIC + Opcodes.ACC_SYNTHETIC, "getSensitivityList" + name,
        "()Lscala/collection/Seq;", "()Lscala/collection/Seq<" + ci(classOf[AbstractSignal[_]]) + ">;")
      import mv._

      visitCode()
      if (sensitivityList.isEmpty) {
        GETSTATIC("scala/collection/immutable/Nil$", "MODULE$", "Lscala/collection/immutable/Nil$;")
      } else {
        GETSTATIC("scala/collection/immutable/List$", "MODULE$", "Lscala/collection/immutable/List$;")
        GETSTATIC("scala/Predef$", "MODULE$", "Lscala/Predef$;")
        pushInt(sensitivityList.size)
        ANEWARRAY(p(classOf[AbstractSignal[_]]))
        for ((signal, i) <- sensitivityList.zipWithIndex) {
          DUP
          pushInt(i)
          ALOAD(0)
          GETFIELD(context.cw.className, signal.name, ci(classOf[AbstractSignal[_]]))
          AASTORE
        }
        CHECKCAST("[Ljava/lang/Object;")
        INVOKEVIRTUAL("scala/Predef$", "wrapRefArray", "([Ljava/lang/Object;)Lscala/collection/mutable/WrappedArray;")
        INVOKEVIRTUAL("scala/collection/immutable/List$", "apply", "(Lscala/collection/Seq;)Lscala/collection/immutable/List;")
      }
      ARETURN
      endMethod()
    }

    def visitProcessStatement(processStmt: ProcessStatement, context: Context) {
      val processName = processStmt.symbol.name
      //TODO createGetSensitivityList(context, processName, processStmt.symbol.sensitivityList)
      val cw = createInnerClass(context.cw, context.cw.className + "$" + processName, processName, if (processStmt.isPostponed) classOf[PostponedProcessAnnotation] else classOf[ProcessAnnotation], createEmptyConstructor = false)
      cw.visitField(Opcodes.ACC_PRIVATE + Opcodes.ACC_FINAL, "$owner", "L" + context.cw.className + ";"); //could be a architecture or entity
      {
        val mv = cw.createMethod(name = "<init>", parameters = "L" + context.cw.className + ";")
        import mv._
        val startLabel = createLabel
        val endLabel = createLabel

        startLabel()
        ALOAD(0)
        INVOKESPECIAL("java/lang/Object", "<init>", "()V")
        ALOAD(0)
        ALOAD(1)
        PUTFIELD(cw.className, "$owner", "L" + context.cw.className + ";")
        acceptDeclarativeItems(processStmt.declarativeItems, 0, Context(cw, mv, Map(), context.designUnit))
        RETURN
        endLabel()
        visitLocalVariable("this", "L" + cw.className + ";", null, startLabel, endLabel, 0)
        visitLocalVariable("owner", "L" + context.cw.className + ";", null, startLabel, endLabel, 1)
        endMethod()
      }
      {
        val mv = cw.createMethod(name = "run")
        visitLoopStatement(LoopStatement(NoPosition, None, processStmt.sequentialStatements, None), Context(cw = cw, mv = mv, loopLabels = Map(), designUnit = context.designUnit)) //infinite loop
        mv.RETURN
        mv.endMethod()
      }
      cw.writeToFile()
    }

    def visitSignalAssignmentStatement(signalAssignStmt: SignalAssignmentStatement, context: Context) {
      // TODO Auto-generated method stub
      import context._

      mv.createDebugLineNumberInformation(signalAssignStmt)
      error("not implemented")
    }

    def loadScalaManifest(dataType: DataType)(implicit mv: RichMethodVisitor) {
      import mv._

      dataType match {
        case scalarType: ScalarType =>
          val scalaType = scalarType match {
            case _: IntegerType => "Int"
            case _: RealType => "Double"
            case _: PhysicalType => "Long"
            case enumeration: EnumerationType =>
              if (enumeration == SymbolTable.booleanType || enumeration == SymbolTable.bitType) "Boolean"
              else if (enumeration.elements.size <= Byte.MaxValue) "Byte"
              else "Char"
          }
          GETSTATIC("scala/reflect/Manifest$", "MODULE$", "Lscala/reflect/Manifest$;")
          INVOKEVIRTUAL("scala/reflect/Manifest$", scalaType, "()Lscala/reflect/AnyValManifest;")
        case dataType =>
          GETSTATIC("scala/reflect/ClassManifest$", "MODULE$", "Lscala/reflect/ClassManifest$;")
          LDC(Type.getType(getJVMDataType(dataType)))
          INVOKEVIRTUAL("scala/reflect/ClassManifest$", "classType", "(Ljava/lang/Class;)Lscala/reflect/ClassManifest;")
      }
    }

    def loadDefaultSubTypeValue(subtype: SubTypeIndication)(implicit mv: RichMethodVisitor) {
      subtype.constraint.foreach {
        _ match {
          case Left(_) =>
          case Right(discreteRanges) =>
            discreteRanges.foreach(loadDiscreteRange)
            val arrayType = subtype.dataType.asInstanceOf[ArrayType]
            mv.INVOKESTATIC(RUNTIME, "createRuntimeArray$" + getScalaSpecializedMethodSuffix(arrayType.elementType),
              "(" + (ci(classOf[scala.Range.Inclusive]) * arrayType.dimensions.size) + ("[" * arrayType.dimensions.size) + getJVMDataType(arrayType.elementType) + ")" + getJVMDataType(arrayType))

        }
      }
    }

    def loadDefaultValue(dataType: DataType)(implicit mv: RichMethodVisitor) {
      (dataType: @unchecked) match {
        case scalarType: ScalarType => mv.pushAnyVal(scalarType.left)
        //case enumType: EnumerationType => GETSTATIC(enumType.implementationName, enumType.elements.head.replace("\'", ""), getJVMDataType(enumType))
        /*case constrainedArrayType: ConstrainedArrayType =>
          constrainedArrayType.dimensions.foreach {
            dim =>
              pushInt((dim.from - dim.to).abs)
              pushInt(dim.from)
              pushInt(dim.to)
          }
          val name = getJVMName(constrainedArrayType)
          INVOKESTATIC(RUNTIME, "create" + name.split("/").last, "(" + ("I" * (3 * constrainedArrayType.dimensions.size)) + ")" + "L" + name + ";")
        case unconstrainedArrayType: UnconstrainedArrayType => ACONST_NULL //TODO
        */
        case arrayType: ConstrainedArrayType =>
          arrayType.dimensions.foreach(dim => mv.pushInt(dim.size))
          arrayType.elementType match {
            case scalarType: ScalarType =>
              //generates this code: int[] x = (int[])VHDLRuntime.fill(6, Integer.valueOf(Integer.MIN_VALUE), Manifest..MODULE$.Int());
              loadDefaultValue(arrayType.elementType)
              doBox(scalarType)
              loadScalaManifest(arrayType.elementType)
              mv.INVOKESTATIC(RUNTIME, "fill", "(" + ("I" * arrayType.dimensions.size) + "Ljava/lang/Object;Lscala/reflect/ClassManifest;)" + ("[" * (arrayType.dimensions.size - 1)) + "Ljava/lang/Object;")
            case dataType =>
              //generates this code:record[] x = (record[])VHDLRuntime.fill(6, record.class, ClassManifest..MODULE$.classType(record.class));
              mv.LDC(Type.getType(getJVMDataType(dataType)))
              loadScalaManifest(dataType)
              mv.INVOKESTATIC(RUNTIME, "fill", "(" + ("I" * arrayType.dimensions.size) + "Ljava/lang/Class;Lscala/reflect/ClassManifest;)" + ("[" * (arrayType.dimensions.size - 1)) + "Ljava/lang/Object;")
          }
          mv.CHECKCAST(("[" * arrayType.dimensions.size) + getJVMDataType(arrayType.elementType))
        case _: RecordType | _: ProtectedType =>
          import mv._
          NEW(dataType.implementationName)
          DUP
          INVOKESPECIAL(dataType.implementationName, "<init>", "()V")
        case fileType: FileType =>
          import mv._
          NEW(getJVMName(dataType))
          DUP
          INVOKESPECIAL(getJVMName(dataType), "<init>", "()V")
        case _: AccessType => mv.ACONST_NULL
      }
    }

    def initSymbols(symbols: Seq[RuntimeSymbol], context: Context)(f: (RuntimeSymbol) => Unit) {
      import context.mv._

      for (symbol <- symbols) {
        symbol.owner match {
          case _: SubprogramSymbol | _: PackageSymbol =>
          case _ => ALOAD(0)
        }
        f(symbol)
        storeSymbol(symbol)
      }
    }

    def visitVariableDeclaration(variableDeclaration: VariableDeclaration, context: Context) {
      initSymbols(variableDeclaration.symbols, context) {
        symbol =>
          import context._

          variableDeclaration.initialValue match {
            case Some(expression) =>
              acceptExpression(expression)
              checkIsInRange(symbol.dataType)
            case None =>
              mv.createDebugLineNumberInformation(variableDeclaration)
              loadDefaultValue(symbol.dataType)
          }
          loadDefaultSubTypeValue(variableDeclaration.subType)
      }
    }

    def visitSignalDeclaration(signalDeclaration: SignalDeclaration, context: Context) =
      error("not implemented")

    def visitConstantDeclaration(constantDeclaration: ConstantDeclaration, context: Context) {
      for (defaultExpression <- constantDeclaration.value) initSymbols(constantDeclaration.symbols, context) {
        symbol =>
          import context._
          acceptExpression(defaultExpression)
          checkIsInRange(symbol.dataType)
      }
    }

    def visitFileDeclaration(fileDeclaration: FileDeclaration, context: Context) {
      import context._
      import mv._

      createDebugLineNumberInformation(fileDeclaration.identifiers.head)
      initSymbols(fileDeclaration.symbols, context) {
        symbol =>
          loadDefaultValue(symbol.dataType)
      }
      if (fileDeclaration.logicalName.isDefined) {
        for (symbol <- fileDeclaration.symbols) {
          loadSymbol(symbol)
          acceptExpressionOption(fileDeclaration.logicalName)
          acceptExpressionOption(fileDeclaration.openKind)
          INVOKESTATIC(RUNTIME, "file_open", "(" + ci(classOf[RuntimeFile]) + "Ljava/lang/String;" + (if (fileDeclaration.logicalName.isDefined) "I" else "") + ")V")
        }
      }
    }

    def visitTypeDeclaration(typeDeclaration: AbstractTypeDeclaration, context: Context) {
      def createInnerClassForType(dataType: DataType with HasOwner, annotation: Class[_], interfaces: Option[Array[String]] = None, createEmptyConstructor: Boolean = true, superClass: String = "java/lang/Object"): RichClassWriter = {
        val className = dataType.implementationName
        dataType.owner match {
          case subprogramSymbol: SubprogramSymbol =>
            context.cw.visitInnerClass(className, null, dataType.name, Opcodes.ACC_FINAL)
            val cw = createClass(Opcodes.ACC_FINAL, className, "java/lang/Object", annotation, interfaces, createEmptyConstructor)
            val returnType = subprogramSymbol match {
              case functionSymbol: FunctionSymbol => getJVMDataType(functionSymbol.returnType)
              case _ => "V"
            }
            cw.visitOuterClass(context.cw.className, subprogramSymbol.name, "(" + getJVMParameterList(subprogramSymbol.parameters) + ")" + returnType)
            cw.visitInnerClass(className, null, dataType.name, Opcodes.ACC_FINAL)
            cw
          case _ => createInnerClass(context.cw, className, dataType.name, annotation, interfaces, createEmptyConstructor, superClass)
        }
      }
      typeDeclaration.dataType match {
        case recordType: RecordType =>
          val cw = createInnerClassForType(recordType, classOf[RecordAnnotation], Some(Array(p(classOf[RecordTypeInterface]))), createEmptyConstructor = false)
          val methodDesc = recordType.fields.map(element => getJVMDataType(element._2)).mkString
          for ((name, dataType) <- recordType.fields) {
            cw.visitField(Opcodes.ACC_PUBLIC, name, getJVMDataType(dataType))
          }
          {
            val mv = cw.createMethod(name = "<init>", parameters = methodDesc, returnType = "V")
            import mv._

            ALOAD(0)
            INVOKESPECIAL("java/lang/Object", "<init>", "()V")
            for (((fieldName, fieldDataType), i) <- recordType.fields.zip(recordType.fields.map(element => getNextIndex(element._2)).scanLeft(1)(_ + _))) {
              ALOAD(0)
              loadInstruction(fieldDataType, i)
              PUTFIELD(recordType.implementationName, fieldName, getJVMDataType(fieldDataType))
            }
            RETURN
            endMethod()
          }
          {
            implicit val mv = cw.createMethod(name = "<init>")
            import mv._

            ALOAD(0)
            INVOKESPECIAL("java/lang/Object", "<init>", "()V")
            for ((fieldName, fieldDataType) <- recordType.fields) {
              ALOAD(0)
              loadDefaultValue(fieldDataType)
              PUTFIELD(recordType.implementationName, fieldName, getJVMDataType(fieldDataType))
            }
            RETURN
            endMethod()
          }
          {
            /*
            generates this code:
                   public String toString() {
                    return "Record(x=" + x + ", y=" + y + ", z=" + z + ")"
                  }
            */
            val mv = cw.createMethod(name = "toString", returnType = "Ljava/lang/String;")
            import mv._
            val startLabel = createLabel
            val endLabel = createLabel

            startLabel()
            val first = recordType.fields.head._1
            NEW("java/lang/StringBuilder")
            DUP
            LDC(recordType.implementationName + "(")
            INVOKESPECIAL("java/lang/StringBuilder", "<init>", "(Ljava/lang/String;)V")
            for ((fieldName, fieldType) <- recordType.fields) {
              if (fieldName != first) LDC(", " + fieldName + "=") else LDC(fieldName + "=")
              INVOKEVIRTUAL("java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;")
              ALOAD(0)
              GETFIELD(recordType.implementationName, fieldName, getJVMDataType(fieldType))
              (fieldType: @unchecked) match {
                case scalarType: ScalarType => INVOKEVIRTUAL("java/lang/StringBuilder", "append", "(" + getJVMDataType(fieldType) + ")Ljava/lang/StringBuilder;")
                case _: AccessType | _: RecordType => INVOKEVIRTUAL("java/lang/StringBuilder", "append", "(Ljava/lang/Object;)Ljava/lang/StringBuilder;")
                case arrayType: ArrayType =>
                  if (arrayType.dimensions.size == 1) INVOKESTATIC("java/util/Arrays", "toString", "(" + getJVMDataType(arrayType) + ")Ljava/lang/String;")
                  else INVOKESTATIC("java/util/Arrays", "deepToString", "([Ljava/lang/Object;)Ljava/lang/String;")
                  INVOKEVIRTUAL("java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;")
              }
            }
            LDC(")")
            INVOKEVIRTUAL("java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;")
            INVOKEVIRTUAL("java/lang/StringBuilder", "toString", "()Ljava/lang/String;")
            ARETURN
            endLabel
            visitLocalVariable("this", "L" + recordType.implementationName + ";", null, startLabel, endLabel, 0)
            endMethod()
          }
          {
            /*
            generates this code:
                public Object copy(){
                  return copy();
              }
            */
            val mv = cw.createMethod(name = "copy", returnType = "Ljava/lang/Object;")
            import mv._
            val startLabel = createLabel
            val endLabel = createLabel


            startLabel()
            ALOAD(0)
            INVOKEVIRTUAL(getJVMName(recordType), "copy", "()" + getJVMDataType(recordType))
            ARETURN
            endLabel()
            visitLocalVariable("this", "L" + recordType.implementationName + ";", null, startLabel, endLabel, 0)
            endMethod()
          }
          {
            /*
            generates this code:
              public Record copy(){
                return new Record(this.x,this.y.clone(),this.z!=null?this.z.copy():null);
              }
            */
            val mv = cw.createMethod(name = "copy", returnType = "L" + recordType.implementationName + ";")
            import mv._
            val startLabel = createLabel
            val endLabel = createLabel
            val l1 = createLabel
            val l2 = createLabel

            startLabel()
            NEW(recordType.implementationName)
            DUP
            for ((fieldName, fieldType) <- recordType.fields) {
              ALOAD(0)
              GETFIELD(recordType.implementationName, fieldName, getJVMDataType(fieldType))
              (fieldType: @unchecked) match {
                case _: ScalarType | _: AccessType =>
                case _: RecordType =>
                  IFNULL(l1)
                  ALOAD(0)
                  GETFIELD(recordType.implementationName, fieldName, getJVMDataType(fieldType))
                  INVOKEVIRTUAL(getJVMName(fieldType), "copy", getJVMDataType(fieldType))
                  GOTO(l2)
                  l1()
                  ACONST_NULL
                  l2()
                case arrayType: ArrayType =>
                  INVOKEVIRTUAL(getJVMDataType(fieldType), "clone", "()Ljava/lang/Object;")
                  CHECKCAST(getJVMDataType(fieldType))
              }
            }
            INVOKESPECIAL(recordType.implementationName, "<init>", "(" + methodDesc + ")V")
            ARETURN
            endLabel
            visitLocalVariable("this", "L" + recordType.implementationName + ";", null, startLabel, endLabel, 0)
            endMethod()
          }
          {
            //generates code for canEqual and equals as described by M. Odersky in this article http://www.artima.com/lejava/articles/equality.html {
            /*
            generates this code:
               public boolean canEqual(Object other) {
                   return (other instanceof ClassName);
               }
            */
            val mv = cw.createMethod(name = "canEqual", parameters = "Ljava/lang/Object;", returnType = "Z")
            import mv._
            val startLabel = createLabel
            val endLabel = createLabel

            startLabel()
            ALOAD(1)
            INSTANCEOF(recordType.implementationName)
            IRETURN
            visitLocalVariable("this", "L" + recordType.implementationName + ";", null, startLabel, endLabel, 0)
            visitLocalVariable("other", "Ljava/lang/Object;", null, startLabel, endLabel, 1)
            endMethod()
          }
          {
            /*
             generates this code:
             public boolean equals(Object other){
               if (this == obj) return true
               if (obj == null) return false
               if (other instanceof ClassName){
                 ClassName that=(ClassName)other;
                 return that.canEqual(this) && this.field1==that.field1 && this.field2==that.field2;
               }
               return false;
             }
            */
            val mv = cw.createMethod(name = "equals", parameters = "Ljava/lang/Object;", returnType = "Z")
            import mv._
            val startLabel = createLabel
            val thatScopeLabel = createLabel
            val afterIfStmtLabel = createLabel
            val falseLabel = createLabel
            val endLabel = createLabel
            val l1 = createLabel
            val l2 = createLabel

            startLabel()
            //generate if (this == obj) return true
            ALOAD(0)
            ALOAD(1)
            IF_ACMPNE(l1)
            ICONST_1
            IRETURN
            l1()
            //generate if (obj == null) return false
            ALOAD(1)
            IFNONNULL(l2)
            ICONST_0
            IRETURN
            l2()

            ALOAD(1)
            INSTANCEOF(recordType.implementationName)
            IFEQ(afterIfStmtLabel)
            ALOAD(1)
            CHECKCAST(recordType.implementationName)
            ASTORE(2)
            thatScopeLabel()
            ALOAD(2)
            ALOAD(0)
            INVOKEVIRTUAL(recordType.implementationName, "canEqual", "(Ljava/lang/Object;)Z")
            IFEQ(falseLabel)
            for ((fieldName, fieldType) <- recordType.fields) {
              ALOAD(0)
              GETFIELD(recordType.implementationName, fieldName, getJVMDataType(fieldType))
              ALOAD(2)
              GETFIELD(recordType.implementationName, fieldName, getJVMDataType(fieldType))
              (fieldType: @unchecked) match {
                case _: IntegerType | _: EnumerationType => IF_ICMPNE(falseLabel)
                case _: RealType =>
                  DCMPL
                  IFNE(falseLabel)
                case _: PhysicalType =>
                  LCMP()
                  IFNE(falseLabel)
                case _: AccessType | _: RecordType =>
                  INVOKEVIRTUAL(getJVMName(fieldType), "equals", "(Ljava/lang/Object;)Z")
                  IFEQ(falseLabel)
                case arrayType: ArrayType =>
                  if (arrayType.dimensions.size == 1) INVOKESTATIC("java/util/Arrays", "equals", "(" + (getJVMDataType(arrayType) * 2) + ")Z")
                  else INVOKESTATIC("java/util/Arrays", "deepEquals", "([Ljava/lang/Object;[Ljava/lang/Object;)Z")
                  IFEQ(falseLabel)
              }
            }
            ICONST_1
            IRETURN
            falseLabel()
            ICONST_0
            IRETURN
            afterIfStmtLabel()
            ICONST_0
            IRETURN
            endLabel()
            visitLocalVariable("this", "L" + recordType.implementationName + ";", null, startLabel, endLabel, 0)
            visitLocalVariable("other", "Ljava/lang/Object;", null, startLabel, endLabel, 1)
            visitLocalVariable("that", "L" + recordType.implementationName + ";", null, thatScopeLabel, afterIfStmtLabel, 2)
            endMethod()
          }
          cw.writeToFile()
        case enumType: EnumerationType =>
          val cw = createInnerClassForType(enumType, classOf[EnumerationAnnotation], Some(Array(p(classOf[EnumerationTypeInterface]))))
          cw.visitField(Opcodes.ACC_PRIVATE + Opcodes.ACC_FINAL + Opcodes.ACC_STATIC, "valuesArray", "[Ljava/lang/String;")
          val dataType = getJVMDataType(enumType)
          for ((enumValueName, index) <- enumType.elements.zipWithIndex) {
            cw.visitField(Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_STATIC, enumValueName.replace("\'", ""), dataType, null, index)
          }
          {
            val mv = cw.createMethod(name = "<clinit>")
            import mv._

            pushInt(enumType.elements.size)
            ANEWARRAY("java/lang/String")
            for ((enumValueName, index) <- enumType.elements.zipWithIndex) {
              DUP
              pushInt(index)
              LDC(enumValueName.replace("\'", ""))
              AASTORE
            }
            PUTSTATIC(enumType.implementationName, "valuesArray", "[Ljava/lang/String;")

            RETURN
            endMethod()
          }
          {
            val mv = cw.createMethod(flags = Opcodes.ACC_SYNTHETIC, name = "getValue", parameters = "I", returnType = "Ljava/lang/String;")
            import mv._

            ILOAD(1)
            INVOKESTATIC(enumType.implementationName, "image", "(I)Ljava/lang/String;")
            ARETURN
            endMethod()
          }
          {
            val mv = cw.createMethod(flags = Opcodes.ACC_STATIC + Opcodes.ACC_SYNTHETIC, name = "value", parameters = "Ljava/lang/String;", returnType = "I")
            import mv._
            val labels = Array.tabulate(enumType.elements.size)(i => new Label())
            val defaultLabel = createLabel

            val dataType = getJVMDataType(enumType)
            ALOAD(0)
            if (enumType.elements.exists(_.contains("'"))) {
              LDC("\'")
              LDC("")
              INVOKEVIRTUAL("java/lang/String", "replace", "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;")
            }
            INVOKEVIRTUAL("java/lang/String", "hashCode", "()I")
            val values = enumType.elements.map(enumName => (enumName.hashCode, enumName)).zipWithIndex.sortBy(x => x._1._1)

            LOOKUPSWITCH(defaultLabel, values.map(_._1._1).toArray, labels)
            for (((_, enumName), i) <- values) {
              visitLabel(labels(i))
              GETSTATIC(enumType.implementationName, enumName.replace("\'", ""), dataType)
              IRETURN
            }
            defaultLabel()
            throwNewException(p(classOf[VHDLRuntimeException]), "invalid enum string")
            endMethod()
          }
          {
            /*        generates code equivalent to
                      def checkIsInRange(value: Int, low: Int, high: Int): Int = {
                      if (value < low || value > high) throw new VHDLRuntimeException("value:" + image(value) + " is out of range " + image(low) + " to " + image(high))
                      value
                      }
            */
            val mv = cw.createMethod(flags = Opcodes.ACC_STATIC + Opcodes.ACC_SYNTHETIC, name = "checkIsInRange", parameters = "III", returnType = "I")
            import mv._
            val throwLabel = createLabel
            val returnLabel = createLabel

            ILOAD(0)
            ILOAD(1)
            IF_ICMPLT(throwLabel)
            ILOAD(0)
            ILOAD(2)
            IF_ICMPLE(returnLabel)
            throwLabel()
            NEW(p(classOf[VHDLRuntimeException]))
            DUP
            NEW("java/lang/StringBuilder")
            DUP
            LDC("value:")
            INVOKESPECIAL("java/lang/StringBuilder", "<init>", "(Ljava/lang/String;)V")
            ILOAD(0)
            INVOKESTATIC(enumType.implementationName, "image", "(I)Ljava/lang/String;")
            INVOKEVIRTUAL("java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;")
            LDC(" is out of range ")
            INVOKEVIRTUAL("java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;")
            ILOAD(1)
            INVOKESTATIC(enumType.implementationName, "image", "(I)Ljava/lang/String;")
            INVOKEVIRTUAL("java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;")
            LDC(" to ")
            INVOKEVIRTUAL("java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;")
            ILOAD(2)
            INVOKESTATIC(enumType.implementationName, "image", "(I)Ljava/lang/String;")
            INVOKEVIRTUAL("java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;")
            INVOKEVIRTUAL("java/lang/StringBuilder", "toString", "()Ljava/lang/String;")
            INVOKESPECIAL(p(classOf[VHDLRuntimeException]), "<init>", "(Ljava/lang/String;)V")
            ATHROW()
            returnLabel()
            ILOAD(0)
            IRETURN
            endMethod()
          }
          {
            val mv = cw.createMethod(flags = Opcodes.ACC_STATIC + Opcodes.ACC_SYNTHETIC, name = "image", parameters = "I", returnType = "Ljava/lang/String;")
            import mv._

            GETSTATIC(enumType.implementationName, "valuesArray", "[Ljava/lang/String;")
            ILOAD(0)
            AALOAD()
            ARETURN
            endMethod()
          }
          cw.writeToFile()
        case protectedType: ProtectedType =>
          val (cw, declarativeItems) = typeDeclaration match {
            case protectedTypeHeader: ProtectedTypeDeclaration =>
              val cw = createInnerClassForType(protectedType, classOf[ProtectedTypeHeaderAnnotation], createEmptyConstructor = false)
              protectedType.subprograms.foreach(subprogram => cw.createMethod(Opcodes.ACC_ABSTRACT, subprogram.parameters.map(getJVMDataType).mkString, subprogram.returnTypeOption.map(getJVMDataType).getOrElse("V")))
              (cw, protectedTypeHeader.declarativeItems)
            case protectedTypeBody: ProtectedTypeBodyDeclaration =>
              val cw = createInnerClassForType(protectedType, classOf[ProtectedTypeBodyAnnotation], createEmptyConstructor = false, superClass = protectedTypeBody.header.implementationName)
              (cw, protectedTypeBody.declarativeItems)
          }
          val mv = cw.createMethod(name = "<init>")
          import mv._
          ALOAD(0)
          INVOKESPECIAL("java/lang/Object", "<init>", "()V")
          acceptDeclarativeItems(declarativeItems, 0, Context(cw, mv, Map(), context.designUnit))
          RETURN
          endMethod()
          cw.writeToFile()
        case _ =>
      }
    }

    def loadParameters(associationListOption: Option[AssociationList])(implicit mv: RichMethodVisitor) =
      for (associationList <- associationListOption) for ((expr, symbol) <- associationList.parameters.zip(associationList.symbols)) {
        acceptExpression(expr)
        //it is an error if, after applying any conversion function or type conversion present in the actual part of the applicable association element (see 4.3.2.2), the value of the actual parameter
        //does not belong to the subtype denoted by the subtype indication of the formal.
        checkIsInRange(symbol.dataType)
      }

    def createInnerClass(parentClass: RichClassWriter, fullClassName: String, className: String, annotation: Class[_], interfaces: Option[Array[String]] = None, createEmptyConstructor: Boolean = true, superClass: String = "java/lang/Object"): RichClassWriter = {
      parentClass.visitInnerClass(fullClassName, parentClass.className, className, Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC + Opcodes.ACC_FINAL)
      val cw = createClass(Opcodes.ACC_FINAL, fullClassName, superClass, annotation, interfaces, createEmptyConstructor)
      cw.visitInnerClass(fullClassName, parentClass.className, className, Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC + Opcodes.ACC_FINAL)
      cw
    }

    def createClass(flags: Int, name: String, superClass: String, annotationClass: Class[_], interfaces: Option[Array[String]] = None, createEmptyConstructor: Boolean = true): RichClassWriter = {
      val cw = if (configuration.debugCodeGenerator) {
        import org.objectweb.asm.util.TraceClassVisitor
        import java.io.PrintWriter

        val cw = new ClassWriter(0)
        val tcv = new TraceClassVisitor(cw, new PrintWriter(System.out, true))
        //new RichClassWriter(configuration.outputDirectory, name, cw,Some(new CheckClassAdapter(tcv)))
        new RichClassWriter(configuration.outputDirectory, name, cw, Some(tcv))
      } else {
        new RichClassWriter(configuration.outputDirectory, name, new ClassWriter(ClassWriter.COMPUTE_FRAMES + ClassWriter.COMPUTE_MAXS))
      }

      cw.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC + Opcodes.ACC_SUPER + flags, name, null, superClass, interfaces.orNull)
      cw.visitAnnotation(ci(annotationClass), true).visitEnd()
      cw.visitSource(sourceFileName, OpenVCSignature)
      if (createEmptyConstructor) cw.createEmptyConstructor()
      cw
    }
  }
}